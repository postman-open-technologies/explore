---
- name: API Design First
  version: '2021-11-24'
  description: Prioritizing the designing of an API using OpenAPI or AsyncAPI before
    any code is written, or application and integration are developed. Designing the
    technical details of the API using a machine-readable contract, mocking the API,
    documenting, and iterating upon the API with stakeholders, and potential consumers--establishing
    a contract for the API before it is developed and deployed into production.
  collection_id: 12959542-636fe166-3ee6-49c3-b220-a52512be75aa
  image: images/blueprints/api-design-first.jpeg
  tags:
  - Design
  roles:
  - Advocate
  - Backend
  - Engineering
  - Frontend
  - Mobile
  - Product  
  state: Work In Progress
  type: Design
  maturity: Optimized
  level: 310
  areas:
  - label: Design
    description: Taking the time to carefully consider and iterate upon the design
      of an API amongst stakeholders, provides a tremendous opportunity for getting
      things right with an API before you just march ahead with historic code-first
      practices. The OpenAPI specification provides us with the scaffolding we need
      to design the surface are of our HTTP APIs, which can be used to publish a mock
      server, produce documentation, and deliver the initial set of contract tests
      we need to ensure the quality of our APIs before they ever go into production.
      API platforms provide us with the capabilities we need to go design first using
      OpenAPI, iterating upon examples used by our mock servers to make the API as
      real as possible, helping us better document, communicate, and evolve around
      a design of our APIs that works for everyone involved.
    image: images/lifecycle-arrow-define.png
    elements:
    - name: OpenAPI
      label: OpenAPI
    - name: Mock Server
      label: Mock Server
    - name: Documentation
      label: Documentation
    - name: Contract Testing
      label: Contract Testing
  - label: Collaboration
    description: Bringing API development out of the individual and team silos that
      often exist today brings the greatest benefits, ensuring that there is communication
      around the evolution of the central API contract, with granular inline discussions
      around specific details of that contract. Allowing for notification when changes
      are made, and sharing of the contract, mock servers, documentation, and testing
      with as many stakeholders as possible. Introducing as many changes as possible
      as early on in the evolution of each API, by making the early design stages
      as collaborative as possible.
    image: images/lifecycle-arrow-define.png
    elements:
    - name: Comments
      label: Comments
    - name: Inline Comments
      label: Inline Comments
    - name: Notifications
      label: Notifications
    - name: Sharing
      label: Sharing
  discussion: ''
  yaml: ''
- name: Prioritizing API-First
  version: '2021-11-24'
  description: API-first is the prioritization of APIs over any single application
    or integration, developing, delivering, and reusing of API resources and capabilities
    beyond their uses. Establishing a better-planned foundation, that is more observable,
    secure, and governed, which then translates into more reliable and successful
    applications and integrations serving business purposes.
  collection_id: 12959542-be45b2ff-0c89-441d-9a7f-bd5414c0d4ec
  image: images/blueprints/prioritizing-api-first.jpeg
  conclusion: Text
  tags:
  - API-First
  roles:
  - Advocate
  - Architect
  - CIO
  - CISO
  - CTO
  - Engineering
  - Product  
  state: Work In Progress
  type: Strategy
  maturity: Foundational
  level: 110
  areas:
  - label: Applications
    description: APIs are behind the applications and integrations we depend on today
      to run our businesses, and by prioritizing APIs over the applications that will
      be using them, we end up with more reliable and secure applications. API-first
      is all about prioritizing the design and development of APIs over any individual
      application, encouraging the reuse of APIs across many different APIs, investing
      in the APIs being as flexible and multi-purpose as possible. Once you prioritize
      the APIs behind applications you begin to see APIs as what is being applied
      on the web, across mobile and other device applications, which opens up entirely
      new ways of applying the digital resources and capabilities your enterprise
      is defining using APIs.
    image: images/lifecycle-arrow-define.png
    elements:
    - name: Web Applications
      label: Web Applications
    - name: Mobile Applications
      label: Mobile Applications
    - name: Device Applications
      label: Device Applications
    - name: Integrations
      label: Integrations
  - label: Definitions
    description: Machine-readable definitions are the cornerstone of an API-first
      approach to doing business in the digital age. A handful of specifications have
      emerged as to how you describe the surface area of your APIs, the digital objects
      they pass back and forth, and the lifecycle that moves APIs forward. API-first
      prioritizes machine-readable artifacts over infrastructure and code, rendering
      the code behind our APIs to a more ephemeral state of existence. Distilling
      the digital resources and capabilities behind our applications and integrations
      down to hundreds, or even thousands of individual API contracts that are versioned,
      and rapidly iterated upon to meet consumer needs.
    image: images/lifecycle-arrow-define.png
    elements:
    - name: OpenAPI
      label: OpenAPI
    - name: AsyncAPI
      label: AsyncAPI
    - name: JSON Schema
      label: JSON Schema
    - name: Collection
      label: Collection
  - label: Discovery
    description: The discovery of APIs, and the operations around them throughout
      their evolution is a critical part of healthy API operations. API discovery
      isn't just about finding the APIs and their machine-readable artifacts in a
      single catalog or portal, but also the teams, workspaces, and other history
      and activity that surrounds them. Pushing our API operations to be discoverable
      by default, not relying on the publishing of every version of an API to a single
      location, and making API operations itself searchable, browsable, and discoverable
      before any new API gets developed, or application and integration are started,
      privately within the firewall, and publicly when it makes sense.
    image: images/lifecycle-arrow-define.png
    elements:
    - name: Team
      label: Team
    - name: Workspace
      label: Workspace
    - name: Artifacts
      label: Artifacts
    - name: Search
      label: Search
    - name: Internal Network
      label: Internal Network
    - name: Partner Network
      label: Partner Network
    - name: Public Network
      label: Public Network
  - label: Visibility
    description: API-first provides much more visibility within the enterprise, but
      also for the resources being made available to partner and 3rd party developers.
      By prioritizing APIs over the applications and integrations that use them you
      are bringing these digital resources and capabilities out of the shadows of
      their applications, making APIs more visible to both producers and consumers.
      A platform-driven approach to being API-first makes it easy for teams and an
      organization to define the visibility that exists across APIs and the lifecycle
      around them, allowing private, team, partner, and public visibility to be established
      as needed, providing much more confidence when it comes to operating APIs at
      scale across the enterprise.
    image: images/lifecycle-arrow-define.png
    elements:
    - name: Private APIs
      label: Private APIs
    - name: Team APIs
      label: Team APIs
    - name: Partner APIs
      label: Partner APIs
    - name: Public APIs
      label: Public APIs
  - label: Observability
    description: Being API-first ensures that every digital resource and capability
      across the enterprise can be made more observable using its existing outputs.
      Allowing API usage history, and the activity around the changes and configuration
      of each API to be observed. Requiring every API and test to be monitored, reported
      upon, and then potentially integrated centrally into existing application performance
      management (APM) solutions. Helping bring observability across 100% of API infrastructure
      behind every application and integration in existence across the enterprise.
      Allowing teams, as well as technical and business leadership to observe not
      just individual APIs, but also the entire state of the complex enterprise system
      that is in motion today.
    image: images/lifecycle-arrow-define.png
    elements:
    - name: Monitor
      label: Monitor
    - name: History
      label: History
    - name: Activity
      label: Activity
    - name: Reports
      label: Reports
    - name: APM
      label: APM
  - label: Standards
    description: API-first is shaped by the usage of common web, industry, and organizational
      standards, allowing teams to pause before they develop any new APIs and consider
      what useful and relevant patterns and schema might already exist, or are required
      when operating within an existing domain. Being API-first provides teams with
      the room they need to not re-invent the wheel and ensure APIs are as intuitive
      and reusable as possible through the adoption of existing patterns, saving time
      and money down the road, and contributing to operations being more productive
      and efficient.
    image: images/lifecycle-arrow-define.png
    elements:
    - name: Internet Standards
      label: Internet Standards
    - name: Industry Standards
      label: Industry Standards
    - name: Organizational Standards
      label: Organizational Standards
  - label: Governance
    description: When the enterprise is API-first it makes it much more likely that
      design, documentation, testing, and other types of governance will be possible.
      API-first always takes that first pause to allow for standards and other governance
      rules to be applied to the design of an API, which will always bring significant
      downstream effects. API-first makes it possible to govern the availability and
      quality of API documentation, as well as help automate the governance of contract,
      integration, performance, and other types of testing that are needed to govern
      the state of the enterprise today.
    image: images/lifecycle-arrow-define.png
    elements:
    - name: Design Governance
      label: Design Governance
    - name: Documentation Governance
      label: Documentation Governance
    - name: Testing Governance
      label: Testing Governance
  discussion: ''
  yaml: ''
- name: Applications and Their APIs
  version: '2021-11-24'
  description: APIs are used to deliver resources and digital capabilities across
    multiple types of applications, providing what is needed to power many different
    web, mobile, and device applications, as well as system-to-system integration
    and automation. How the enterprise sees applications and integrations evolves
    once they begin shifting towards an API-first way of looking at operations, demonstrating
    how APIs are behind every digital application we depend on today.
  collection_id: 12959542-0c3bc307-be50-4f9e-8aaf-5dff516d3ae7
  image: images/blueprints/applications-and-their-apis.png
  conclusion: Text
  maturity: Foundational
  level: 115
  tags:
  - Applications
  roles:
  - Architect
  - CIO
  - CISO
  - CTO
  - Engineering
  - Product
  - Frontend
  - Mobile  
  state: Work In Progress
  type: Applications
  areas:
  - label: Types
    description: There are many different types of applications that depend on APIs
      for whatever they do. Early on in the evolution of the web developers figured
      out that APIs made their applications more distributed in nature, but it wasn't
      until the introduction of the iPhone and Android mobile devices that we began
      to see APIs also power mobile applications. Once lightweight web APIs proved
      useful for communication via unreliable mobile networks, device manufacturers
      also saw the potential for powering what has now become known as the Internet
      of Things. Pushing APIs further to the edge, powering devices, but also the
      networks and infrastructure beneath our applications, and APIs, making it APIs
      all the way down.
    image: images/lifecycle-arrow-define.png
    elements:
    - name: Web
      label: Web
    - name: Mobile
      label: Mobile
    - name: Device
      label: Device
    - name: Integrations
      label: Integrations
    - name: Workflows
      label: Workflows
    - name: Network
      label: Network
  - label: Lifecycle
    description: Through the standardization of the lifecycle across the APIs behind
      different types of applications, we are also standardizing the resources and
      capabilities available via those applications. Change is inevitable in a digital
      world, and the establishment of a common well-known lifecycle for moving forward
      APIs is the only way to get a handle on change across operations and begin moving
      things forward in a consistent way. After twenty years of evolution, the API
      lifecycle can be consistently distilled down into six main areas that help stabilize
      the resources and capabilities that our applications and integrations depend
      upon.
    image: images/lifecycle-arrow-define.png
    elements:
    - name: Discovery
      label: Discovery
    - name: Define
      label: Define
    - name: Design
      label: Design
    - name: Develop
      label: Develop
    - name: Deploy
      label: Deploy
    - name: Observe
      label: Observe
  - label: Observablity
    description: APIs each come with their own set of outputs that we can monitor
      to observe the state of each API. Helping us standardize how we observe the
      state of the systems behind the web, mobile, device, network, and other types
      of applications we depend on. APIs have outputs, but also the infrastructure
      behind our APIs have outputs, opening up a whole new dimension to the operations
      automation and orchestration that is possible today, and how we not only observe
      the state of the APIs behind our applications, but also the infrastructure below
      the APIs. Allowing us to pipe every layer of our operations into a single place
      for reporting and engaging via APM dashboards.
    image: images/lifecycle-arrow-define.png
    elements:
    - name: Testing
      label: Testing
    - name: Security
      label: Security
    - name: Monitor
      label: Monitor
    - name: Pipeline
      label: Pipeline
    - name: APM
      label: APM
    - name: Reports
      label: Reports
  discussion: ''
  yaml: ''
- name: Build a Business Workflow
  version: '2021-09-11'
  description: This API lifecycle blueprint focuses on defining common business workflows,
    then automating around these well-defined scenarios. Defining collections across
    multiple APIs, including authentication, scripting, data, Environment, then automating
    using monitors and pipelines.
  collection_id: 12959542-b0464d83-5da2-4db5-857e-371e06d3fa7a
  image: images/blueprints/build-a-business-workflow.jpeg
  conclusion:
  tags:
  - Workflows
  - Business
  roles:
  - Advocate
  - Architect
  - Backend
  - CIO
  - CISO
  - CTO
  - Data
  - Operations
  - Engineering
  - Frontend
  - Mobile
  - Product
  - Sales
  - Security
  - Support
  - Writer  
  state: Ready for Use
  type: Automation
  maturity: Optimized
  level: 280
  areas:
  - label: Define
    description: Ensuring that operations supporting an API are properly defined,
      as well as what is needed to properly design and bring an API to life. A little
      planning and organization at this step of an APIs journey can go a long way
      towards ensuring the overall health and velocity of an API, and the applications
      that depend on this internal, partner, or public API.
    image: images/lifecycle-arrow-define.png
    elements:
    - name: Team Workspace
      label: Team Workspace
  - label: Design
    image: images/lifecycle-arrow-design.png
    description: Having a formal process and approach to designing an API helps establish
      consistency and the precision of APIs in production, ensuring that APIs are
      developed using common patterns across an industry, and within an organization,
      establishing known practices for shaping the surface area and behaviors of APIs
      that applications are depending upon.
    elements:
    - name: Workflow Collection
      label: Workflow Collection
  - label: Document
    image: images/lifecycle-arrow-document.png
    description: Having complete, accurate, and easy to follow document is essential
      for all APIs, helping alleviate the number one pain point for API consumers
      when it comes to onboarding with an API, as well as expanding the number of
      API paths an application puts to work, making API documentation one of the most
      important areas of the API lifecycle.
    elements:
    - name: Workflow Documentation
      label: Workflow Documentation
  - label: Testing
    image: images/lifecycle-arrow-test.png
    description: A test-driven API lifecycle ensures that each API accomplishes the
      intended purpose it was developed for, providing manual and automated ways to
      ensure an API hasn't changed unexpectedly, is as performant as required, and
      meets the security expectations of everyone involved, helping establish a high
      quality of service consistently across all APIs.
    elements:
    - name: Workflow Testing
      label: Workflow Testing
  - label: Monitor
    image: images/lifecycle-arrow-monitor.png
    description: All tests applied to an API should be monitored on a logical schedule
      and from relevant geographic regions, monitoring that APIs aren't breaking their
      contract, falling below their agreed-upon service level agreement (SLA), or
      becoming a security risk, helping automate the quality of service across APIs
      in a way that allows teams to be as productive as possible.
    elements:
    - name: Workflow Testing Monitor
      label: Workflow Testing Monitor
    - name: Workflow Testing Monitor Results
      label: Workflow Testing Monitor Results
  discussion: https://github.com/postman-open-technologies/lifecycle/discussions/29
  yaml: https://github.com/postman-open-technologies/lifecycle/blob/main/_blueprints/business-workflows.md
- name: Defining Capabilities Using Collections
  version: '2021-11-24'
  description: A capability collection is a small single-use collection designed to
    accomplish a specific task, and represent a single capability of an API producer
    and the organization behind it. Providing a single well-documented API request
    that accomplishes a specific business objective, helping reduce the cognitive
    load when it comes to putting an API to work.
  collection_id: 12959542-907e208f-42c4-4839-aaa9-3e04d12819e1
  image: images/blueprints/defining-capabilities-using-collections.jpeg
  tags:
  - Capabilities
  - Collections
  roles:
  - Advocate
  - Architect
  - Engineering
  - Product
  - Operations  
  state: Work in Progress
  type: Definitions
  maturity: Optimized
  level: 320  
  areas:
  - label: Purpose
    description: Capability collections allow us to explain the purpose of an API
      in a specific context, going well beyond the generic description of an API present
      as part of reference collections and documentation. Wrapping a single API request
      in more context and detail that speaks to a specific scenario, application,
      and purpose. By reducing the overall scope required to engage with a single
      API path we are potentially opening up new consumer use cases, ways of organizing
      and presenting APIs, changing the discovery and potentially the narrative around
      what each API can do, getting more creative in how we package up our APIs for
      consumers.
    image: images/lifecycle-arrow-define.png
    elements:
    - name: Single Purpose
      label: Single Purpose
    - name: Cognitive Load
      label: Cognitive Load
    - name: Automation
      label: Automation
    - name: Orchestration
      label: Orchestration
    - name: Engagement
      label: Engagement
  - label: Structure
    description: The number of requests should be limited within capability collections,
      but the structure of them should maximize the structure of a collection by taking
      full advantage of the collection specification. Helping each granular capability
      to be as full-featured and robust as possible. The power of a capability goes
      well beyond the limited scope and a more relevant title and description, pushing
      the producer to think about what other affordances can be provided to demonstrate
      what is possible with each digital capability,  Helping maximize the functionality,
      but also reduce friction when it comes to forking and putting a collection to
      work as part of other workflows, automation, and orchestration, or all by itself
      as a single executable gear within API operations.
    image: images/lifecycle-arrow-define.png
    elements:
    - name: Authentication
      label: Authentication
    - name: Folders
      label: Folders
    - name: Request
      label: Request
    - name: Scripts
      label: Scripts
    - name: Examples
      label: Examples
  - label: Environment
    description: Common elements required to run a capability collection should be
      abstracted away to an environment. Allowing whoever has forked the capability
      collection to easily define what is needed to authenticate, operate, and maintain
      a state of the capability being executed. Abstracting away secrets, tokens,
      and other key/value pairs that are needed to execute the capability collection,
      but also potentially storing data that may have been created, altered, and removed
      as part of running each individual capability. Enabling each capability collection
      to be powered, but also potentially for many different capability collections
      to be executed for a single specific environment.
    image: images/lifecycle-arrow-define.png
    elements:
    - name: State
      label: State
    - name: Variables
      label: Variables
    - name: Authorization Variables
      label: Authorization Variables
  - label: Engagement
    description: Capability collections reduce what it takes to engage with each individual
      API capability, but also at the same time widen the number of ways in which
      consumers can engage. The precision of a capability collection is perfect for
      very granular sharing via a URL, embedding within a blog post or on documentation
      using a button, but also allows that individual capability to be forked, and
      have pull requests submitted, and potentially allow for merging of individual
      details of a single capability--reducing the cognitive load for defining, engaging,
      and executing each individual API capability, but also encouraging contributions
      from consumers via a single collection.
    image: images/lifecycle-arrow-define.png
    elements:
    - name: Collection URL
      label: Collection URL
    - name: Collection Button
      label: Collection Button
    - name: Collection Watch
      label: Collection Watch
    - name: Collection Fork
      label: Collection Fork
    - name: Collection Pull Request
      label: Collection Pull Request
    - name: Collection Merge
      label: Collection Merge
  discussion: ''
  yaml: ''
- name: Creating a New GraphQL API
  version: '2021-09-11'
  description: This is a blueprint for pushing this API lifecycle blueprint to also
    work for new GraphQL APIs, identifying the steps needed to define and stand up
    a new GraphQL API, but then apply a consistent well-defined lifecycle to how the
    API is moved forward and supported in production.
  collection_id: 12959542-3866c354-9d59-4515-a343-194079e557aa
  image: images/blueprints/creating-a-new-graphql-api.jpeg
  tags:
  - GraphQL
  roles:
  - Architect
  - Backend
  - Operations
  - Engineering
  - Frontend
  - Mobile
  - Product  
  state: Ready for Use
  type: New
  maturity: Optimized
  level: 310
  areas:
  - label: Define
    image: images/lifecycle-arrow-define.png
    description: GraphQL provides a rich set of solutions for defining the base of
      an API that will expose the entire surface area of one or many data sources,
      providing API producers with the ability to define data sources and the resolvers
      that route API requests to each data source, and the schema that will define
      how API consumers can craft queries for getting at exactly the data they need.
      Each of these elements helps define the base for a GraphQL API, bypassing the
      work that is required to design a more RESTful approach to delivering APIs,
      putting more control into the hands of API consumers. Providing a solid approach
      to defining access to essential and complex backend data using an increasingly
      common API pattern.
    elements:
    - name: Schema
      label: Schema
    - name: Data Sources
      label: Data Sources
    - name: Resolvers
      label: Resolvers
  - label: Document
    image: images/lifecycle-arrow-document.png
    description: Having complete, accurate, and easy-to-follow documentation is essential
      for all APIs and is something that alleviates the number one pain point for
      API consumers when it comes to onboarding with any API, expanding the number
      of API paths an application puts to work. Modern approaches to producing API
      documentation have moved beyond a single static version of documentation simply
      published to a portal, as well as there being potentially multiple forms of
      documentation for any single API. Helping API producers onboard consumers easier,
      reducing the cognitive load when understanding what an API does, and properly
      defining specific business use cases of an API being put to work in an application
      or as part of an integration.
    elements:
    - name: Reference Documentation
      label: Reference Documentation
      context: 1
  - label: Testing
    image: images/lifecycle-arrow-test.png
    description: A test-driven API lifecycle ensures that each API delivers the intended
      outcomes it was developed for in the first place, providing manual as well as
      automated ways to ensure an API hasn't changed unexpectedly and is as performant
      as required, helping establish a high quality of service consistently across
      all APIs. API testing should not be an afterthought and should be a default
      aspect of the API lifecycle for any API being put into production. API testing
      takes a solid investment in establishing proper testing practices across teams,
      but once you do the work to establish a baseline of testing, properly train
      teams on the process and tooling involved, the investment will pay off down
      the road.
    elements:
    - name: Contract Testing
      label: Contract Testing
      context: 1
    - name: Performance Testing
      label: Performance Testing
      context: 1
  - label: Secure
    image: images/lifecycle-arrow-test.png
    description: Security must be its own area of the API lifecycle, but it is something
      that should span testing, authentication, and potentially other areas of the
      API lifecycle. Over the last five years, the world of API security has expanded,
      while also moving further left in the API lifecycle as part of an operations
      shift in how APIs are delivered. There are a number of elements present when
      it comes to security, but depending on the overall maturity of API operations
      the available resources and prioritization available to adequately realize these
      elements vary.
    elements:
    - name: Authentication
      label: Authentication
      context: 1
    - name: Security Testing
      label: Security Testing
      context: 1
  - label: Monitor
    image: images/lifecycle-arrow-monitor.png
    description: Monitors can be used to execute any Postman collection applied to
      any environment. Due to the versatility of what a Postman collection can define,
      collections turn monitors into powerful API automation and orchestration tool.
      Beginning with the ability to schedule contract, performance, and other types
      of tests, but then also allowing for automating specific workflows across many
      different APIs. Since collections can be used to define anything that can be
      defined via an API, monitors can be used to schedule the running of each capability
      from multiple cloud regions, applying many different environmental variables.
      Making monitors an essential, versatile, and executable part of defining how
      the API lifecycle works.
    elements:
    - name: Contract Testing Monitor
      label: Contract Testing Monitor
      context: 1
    - name: Performance Testing Monitor
      label: Performance Testing Monitor
      context: 1
  - label: Discovery
    image: images/lifecycle-arrow-discover.png
    description: The ability to discover APIs at all states of the API lifecycle is
      essential for reducing redundancy across operations, helping teams find existing
      APIs before they develop new ones, properly matching API consumers with the
      right APIs, while supporting documentation, relevant workflows, and the feedback
      loops that exist as part of the operation of APIs internally within the enterprise,
      or externally with 3rd party developers. API discovery does not live at the
      beginning of the end of the API lifecycle, but should be considered across all
      areas of the API lifecycle, ensuring that APIs, as well as the operations around
      them, are as discoverable as possible, but well informed when it comes to privacy,
      security, and terms of service.
    elements:
    - name: Search
      label: Search
      context: 1
    - name: Private Network
      label: Private Network
      context: 1
    - name: Public Network
      label: Public Network
      context: 1
  discussion: https://github.com/postman-open-technologies/lifecycle/discussions/28
  yaml: https://github.com/postman-open-technologies/lifecycle/blob/main/_blueprints/creating-a-new-graphql-api.md
- name: An API Design Review
  version: '2021-09-11'
  description: A design review establishes a period in which an API designer or developer
    can submit an API for review by a formal design reviewer, as well as architects
    from a centralized API governance group, evaluating the API for compliance against
    an organization's governance design guidelines.
  collection_id: 12959542-111b534f-ed6c-4a83-abc2-d2eb818a16bf
  image: images/blueprints/an-api-design-review.jpeg
  tags:
  - Design
  - Governance
  roles:
  - Architect
  - Operations
  - Engineering
  - Product  
  state: Ready for Use
  type: Design
  maturity: Optimized
  level: 330
  areas:
  - label: Define
    description: Each API being submitted as part of an API design review process
      should possess the necessary artifacts and elements needed to properly evaluate
      the design of each API. To ensure the API design review is as efficient and
      effective as possible it helps to have a dedicated location for the review to
      happen, with everything present to conduct a review, and provide feedback around
      the API, as well as supporting elements. Setting the state for a speedy but
      effective review, sending an API back to development, or allowing it to move
      everything forward to production.
    image: images/lifecycle-arrow-define.png
    elements:
    - name: Team Workspace
      label: Team Workspace
      context: 1
    - name: Team Members
      label: Team Members
      context: 1
    - name: Github Repository
      label: Github Repository
      context: 1
    - name: Design Rules
      label: Design Rules
      context: 1
    - name: OpenAPI
      label: OpenAPI
      context: 1
    - name: Reference Documentation
      label: Reference Documentation
      context: 1
    - name: Examples
      label: Examples
      context: 1
    - name: Mock Server
      label: Mock Server
      context: 1
    - name: Contract Testing
      label: Contract Testing
      context: 1
  - label: Process
    image: images/lifecycle-arrow-test.png
    description: Once ready, with all the needed artifacts and elements, an API should
      be submitted to a well-defined process for reviewing the design of an API, then
      providing feedback on the state of an API, and whether it is ready for production,
      in as short of time as possible. Reaching a desirable outcome that upholds an
      organization's design guidelines, and helps make teams better at what they do.
      Ensuring that eery API design review is a learning opportunity for both designer
      and reviewer. Continuing to improve the API design process with each API submitted
      for review, making operations incrementally better along the way.
    elements:
    - name: Design Review
      label: Design Review
    - name: Design Review Timeline
      label: Design Review Timeline
    - name: Design Review Feedback
      label: Design Review Feedback
    - name: Design Review Outcomes
      label: Design Review Outcomes
  discussion: https://github.com/postman-open-technologies/lifecycle/discussions/33
  yaml: https://github.com/postman-open-technologies/lifecycle/blob/main/_blueprints/test-automation.md
- name: API Discovery as the Default
  version: '2021-11-24'
  description: API discovery is about being able to find and see your API resources
    and capabilities whenever you need them, whether it is before you begin developing
    a new API, developing a web, mobile, or device application, and properly route
    traffic and deliver reliable applications and integrations. Ensuring you know
    where all your digital resources and capabilities are, so they can be secured
    and put to work as needed.
  collection_id: 12959542-e5916ff1-8834-48ce-9fb8-cc2adb65b8b4
  image: images/blueprints/discovery-as-the-default.jpeg
  tags:
  - Discovery
  roles:
  - Advocate
  - Architect
  - CIO
  - CISO
  - CTO
  - Engineering
  - Product
  - Operations  
  state: Work in Progress
  type: Discovery
  maturity: Foundational
  level: 150
  areas:
  - label: Components
    description: API discovery begins with being able to find each individual API,
      but then also should help discover the documentation, mock servers, tests, and
      other elements of API operations. API discovery will occur at different points
      in the evolution of applications, integrations, and the APIs behind them, and
      ensuring that API discovery goes beyond just the API, OpenAPI, and its documentation,
      helps make the lifecycle much more observable to both producers and consumers.
      API discovery today isn't about just finding APIs in a catalog, it is about
      finding the APIs and their supporting operations wherever they exist, and the
      work on them is occurring, helping make discovery a default par to operations.
    image: images/lifecycle-arrow-define.png
    elements:
    - name: Workspace
      label: Workspace
    - name: APIs
      label: APIs
    - name: Documentation
      label: Documentation
    - name: Mock Server
      label: Mock Server
    - name: Testing
      label: Testing
    - name: Monitor
      label: Monitor
  - label: Mechanism
    description: API discovery occurs in different ways at different layers of our
      API operations. API discovery isn't as deliberate as someone browsing or searching
      for APIs, and can occur automatically depending on what the motivation of a
      platform, service or tooling is. API discovery needs to be made as natural and
      default part of what is happening as part of operations, and teams should be
      prompted along the way to help make APIs more discoverable through the addition
      of metadata, publishing, and changing the visibility of their workspaces. Helping
      balance the work required of teams with what is possible when it comes to automating
      and making API discovery a natural behind-the-scenes part of how we do our API
      work each day.
    image: images/lifecycle-arrow-define.png
    elements:
    - name: Search
      label: Search
    - name: Browse
      label: Browse
  - label: Visibility
    description: The discovery of APIs is heavily shaped by the visibility of workspace,
      APIs, collections, documentation, testing, and other elements of operations.
      Making it easy, but also ensuring that team members have put proper thought
      into whether APIs and their operations should be limited to private or team
      discovery, or expanded to include partners or public 3rd party developers, should
      be a regular part of operations that is enabled by the platform. API discovery
      isn't just about finding APIs and the operations around them, it is about making
      sure this is discoverable privately, publicly, and limited to just partners,
      making sure APIs can be found, but only by the intended audience that makes
      sense.
    image: images/lifecycle-arrow-define.png
    elements:
    - name: Private
      label: Private
    - name: Partner
      label: Partner
    - name: Public
      label: Public
  - label: Purpose
    description: The purpose behind API discovery will define the components, mechanisms,
      and visibility of the API, but also the time available to find what is needed.  Even
      if API discovery is available, it is not a guarantee that team members will
      do the work to find APIs before they get to work developing a new API, application,
      or integration. Pushing API discovery to also be about training and educations,
      as well as the components, mechanisms, and visibility of our API operations.
      Which, when done well, can help make API discovery a natural part of API operations,
      and something you naturally do as part of your work, and not just something
      you only accomplish if you have the time.
    image: images/lifecycle-arrow-define.png
    elements:
    - name: New APIs
      label: New APIs
    - name: New Applications
      label: New Applications
    - name: New Integrations
      label: New Integrations
  discussion: ''
  yaml: ''
- name: API Documentation is Fundamental
  version: '2021-11-24'
  description: Discoverable, accessible, and always up-to-date API documentation is
    the number one paint point for API consumers, and ensuring that it is present
    for all APIs is fundamental to allowing team members, stakeholders, and consumers
    to understand what an API does, and how it can be put to work, making it a growing
    problem as the number of APIs continues to expand.
  collection_id: 12959542-503e6585-2787-47db-be02-d7804c82f7d4
  image: images/blueprints/api-documentation-is-fundamental.jpeg
  tags:
  - Documentation
  roles:
  - Advocate
  - Architect
  - Engineering
  - Product
  - Backend
  - Support  
  state: Work in Progress
  type: Documentation
  maturity: Foundational
  level: 110
  areas:
  - label: Components
    description: To help produce the most useful API documentation possible it helps
      to pause and think about each of the individual components of what makes API
      documentation valuable to each consumer.  Take a moment to consider the investment
      needed in metadata, examples, code snippets, and the other aspects of documentation
      that make them as usable as possible to API consumers. Then making sure the
      desired components are present for every single API made available internally
      or externally within an enterprise, being consistent, while also going the extra
      mile to make sure the most meaningful components of our API documentation are
      always present, no matter which team is behind the API.
    image: images/lifecycle-arrow-define.png
    elements:
    - name: Documentation Title
      label: Documentation Title
    - name: Documentation Description
      label: Documentation Description
    - name: Documentation Requests
      label: Documentation Requests
    - name: Documentation Examples
      label: Documentation Examples
    - name: Documentation Snippets
      label: Documentation Snippets
  - label: Engagement
    description: 'The ways in which consumer engage with API document has evolved
      over the years. Documentation has become much more decentralized and sharable
      via URLs, and embedded within portals, documentation, help centers, and woven
      into the narrative of our operations with embeddable buttons each day. Documentation
      has become much more interactive and living as part of teams, lines of business,
      and communities, allowing stakeholders to fork, submit pull requests, and merge
      changes back into the documentation in real-time. Shifting engagement for documentation
      beyond just a single portal, and something that needs to occur wherever work
      or conversations are occurring on a regular basis. '
    image: images/lifecycle-arrow-define.png
    elements:
    - name: Collection URL
      label: Collection URL
    - name: Collection Button
      label: Collection Button
    - name: Collection Watch
      label: Collection Watch
    - name: Collection Fork
      label: Collection Fork
    - name: Collection Pull Request
      label: Collection Pull Request
    - name: Collection Merge
      label: Collection Merge
  discussion: ''
  yaml: ''
- name: Generate Collection From Mobile Application API
  version: '2021-09-11'
  description: This blueprint introduces how APIs behind mobile applications can be
    reverse-engineered and defined as a collection so that documentation, testing,
    and other common areas of the API lifecycle can be applied to help stabilize the
    APIs we depend on behind our applications.
  image: images/blueprints/generate-collection-from-mobile-application.jpeg
  tags:
  - Applications
  - Collections
  roles:
  - Advocate
  - Architect
  - Backend
  - Operations
  - Engineering
  - Frontend
  - Mobile
  - Product
  - Support
  - Writer  
  state: Ready for Use
  type: Applications
  maturity: Optimized
  level: 330
  areas:
  - label: Define
    image: images/lifecycle-arrow-define.png
    description: Ensuring that operations supporting an API are properly defined,
      as well as what is needed to properly design and bring an API to life. A little
      planning and organization at this step of an APIs journey can go a long way
      towards ensuring the overall health and velocity of an API, and the applications
      that depend on this internal, partner, or public API.
    elements:
    - name: Proxy
      label: Proxy
    - name: Traffic Collection
      label: Traffic Collection
  - label: Document
    image: images/lifecycle-arrow-document.png
    description: Having complete, accurate, and easy to follow document is essential
      for all APIs, helping alleviate the number one pain point for API consumers
      when it comes to onboarding with an API, as well as expanding the number of
      API paths an application puts to work, making API documentation one of the most
      important areas of the API lifecycle.
    elements:
    - name: Reference Documentation
      label: Reference Documentation
  - label: Testing
    image: images/lifecycle-arrow-test.png
    description: A test-driven API lifecycle ensures that each API accomplishes the
      intended purpose it was developed for, providing manual and automated ways to
      ensure an API hasn't changed unexpectedly, is as performant as required, and
      meets the security expectations of everyone involved, helping establish a high
      quality of service consistently across all APIs.
    elements:
    - name: Contract Testing
      label: Contract Testing
    - name: Performance Testing
      label: Performance Testing
    - name: Security Testing
      label: Security Testing
  - label: Monitor
    image: images/lifecycle-arrow-monitor.png
    description: All tests applied to an API should be monitored on a logical schedule
      and from relevant geographic regions, monitoring that APIs aren't breaking their
      contract, falling below their agreed-upon service level agreement (SLA), or
      becoming a security risk, helping automate the quality of service across APIs
      in a way that allows teams to be as productive as possible.
    elements:
    - name: Contract Testing Monitor
      label: Contract Testing Monitor
    - name: Performance Testing Monitor
      label: Performance Testing Monitor
    - name: Security Testing Monitor
      label: Security Testing Monitor
  - label: Discovery
    image: images/lifecycle-arrow-discover.png
    description: The ability to discover APIs at all states of the API lifecycle is
      key to reducing redundancy across operations, helping teams find existing APIs
      before they develop new ones, and properly match API consumers with the right
      APIs, supporting documentation, relevant workflows, and feedback loops that
      exist as part of the operation of APIs internally within the enterprise, or
      externally with 3rd party developers.
    elements:
    - name: Private Network
      label: Private Network
    - name: Public Network
      label: Public Network
    - name: Search
      label: Search
  discussion: https://github.com/postman-open-technologies/lifecycle/discussions/10
  yaml: https://github.com/postman-open-technologies/lifecycle/blob/main/_blueprints/generate-collection-from-mobile-application.md
  collection_id: 12959542-2321d164-69b4-44de-ae43-9de23696c44d
- name: Generate Collection From Web Application API
  version: '2021-09-11'
  description: This blueprint introduces how APIs behind web applications can be reverse-engineered
    and defined as a collection so that documentation, testing, and other common areas
    of the API lifecycle can be applied to help stabilize the APIs we depend on behind
    our applications.
  image: images/blueprints/generate-collection-from-web-application.png
  collection_id: 12959542-e9816f6c-985c-44dd-8c57-28ce79c115a5
  tags:
  - Applications
  - Collections
  roles:
  - Advocate
  - Architect
  - Backend
  - Operations
  - Engineering
  - Frontend
  - Mobile
  - Product
  - Support
  - Writer  
  state: Ready for Use
  type: Applications
  maturity: Optimized
  level: 330
  areas:
  - label: Define
    image: images/lifecycle-arrow-define.png
    description: Ensuring that operations supporting an API are properly defined,
      as well as what is needed to properly design and bring an API to life. A little
      planning and organization at this step of an APIs journey can go a long way
      towards ensuring the overall health and velocity of an API, and the applications
      that depend on this internal, partner, or public API.
    elements:
    - name: Interceptor
      label: Interceptor
    - name: Traffic Collection
      label: Traffic Collection
  - label: Document
    image: images/lifecycle-arrow-document.png
    description: Having complete, accurate, and easy to follow document is essential
      for all APIs, helping alleviate the number one pain point for API consumers
      when it comes to onboarding with an API, as well as expanding the number of
      API paths an application puts to work, making API documentation one of the most
      important areas of the API lifecycle.
    elements:
    - name: Reference Documentation
      label: Reference Documentation
  - label: Testing
    image: images/lifecycle-arrow-test.png
    description: A test-driven API lifecycle ensures that each API accomplishes the
      intended purpose it was developed for, providing manual and automated ways to
      ensure an API hasn't changed unexpectedly, is as performant as required, and
      meets the security expectations of everyone involved, helping establish a high
      quality of service consistently across all APIs.
    elements:
    - name: Contract Testing
      label: Contract Testing
    - name: Performance Testing
      label: Performance Testing
    - name: Security Testing
      label: Security Testing
  - label: Monitor
    image: images/lifecycle-arrow-monitor.png
    description: All tests applied to an API should be monitored on a logical schedule
      and from relevant geographic regions, monitoring that APIs aren't breaking their
      contract, falling below their agreed-upon service level agreement (SLA), or
      becoming a security risk, helping automate the quality of service across APIs
      in a way that allows teams to be as productive as possible.
    elements:
    - name: Contract Testing Monitor
      label: Contract Testing Monitor
    - name: Performance Testing Monitor
      label: Performance Testing Monitor
    - name: Security Testing Monitor
      label: Security Testing Monitor
  - label: Discovery
    image: images/lifecycle-arrow-discover.png
    description: The ability to discover APIs at all states of the API lifecycle is
      key to reducing redundancy across operations, helping teams find existing APIs
      before they develop new ones, and properly match API consumers with the right
      APIs, supporting documentation, relevant workflows, and feedback loops that
      exist as part of the operation of APIs internally within the enterprise, or
      externally with 3rd party developers.
    elements:
    - name: Private Network
      label: Private Network
    - name: Public Network
      label: Public Network
    - name: Search
      label: Search
  discussion: https://github.com/postman-open-technologies/lifecycle/discussions/12
  yaml: https://github.com/postman-open-technologies/lifecycle/blob/main/_blueprints/generate-collection-from-web-application.md
- name: Generate OpenAPI Using Code Annotations
  version: '2021-09-11'
  description: This is a blueprint for entering the API lifecycle by generating an
    OpenAPI using code annotations, taking a code-first approach to bringing each
    API to life, while still ensuring that there is a contract to help guide the API
    across a more standardized API lifecycle.
  collection_id: 12959542-d25e1414-f551-439e-8a3c-496809278442
  image: images/blueprints/generate-openapi-using-code-annotations.png
  conclusion: ''
  tags:
  - Code-First
  - Code Annotations
  roles:
  - Advocate
  - Architect
  - Backend
  - Operations
  - Engineering
  - Frontend
  - Mobile
  - Product
  - Writer  
  state: Ready for Use
  type: Code
  maturity: Foundational
  level: 340
  areas:
  - label: Define
    description: The most important first step of any API lifecycle is to make sure
      the operations around an API are properly defined, laying the foundation for
      being able to effectively design and bring an API to life, while also establishing
      a known place, or places to go to get all the information you need regarding
      each individual API or groups of APIs. A little planning and organization at
      this early step of the API journey can go a long way towards ensuring the overall
      health and velocity of an API, and the applications and integrations that will
      depend on each internal, partner, or public API being delivered.
    image: images/lifecycle-arrow-define.png
    elements:
    - name: Team Workspace
      label: Team Workspace
      context: 1
    - name: Team Members
      label: Team Members
      context: 1
    - name: Github Repository
      label: Github Repository
      context: 1
  - label: Deploy
    image: images/lifecycle-arrow-deploy.png
    description: The road to setting a new code-first or existing API on a road to
      a standardized API lifecycle oftentimes begins with the generation of an OpenAPI
      from annotations in the code as part of a build process. Relying on annotations
      for each coding method to produce an API for the surface area of the API, updating
      the OpenAPI, and other supporting documentation and tests using a CI/CD pipeline.
      Bypassing the API design process and going with a code-first approach to delivering
      an API, and relying on the pipeline for the existing software development lifecycle
      to generate the OpenAPI, and set in motion the delivery of documentation, testing,
      and other elements of the API lifecycle.
    elements:
    - name: CI/CD Pipeline
      label: CI/CD Pipeline
      context: 1
    - name: Code Annotations
      label: Code Annotations
      context: 1
    - name: OpenAPI
      label: OpenAPI
      context: 1
  - label: Document
    image: images/lifecycle-arrow-document.png
    description: Having complete, accurate, and easy-to-follow documentation is essential
      for all APIs and is something that alleviates the number one pain point for
      API consumers when it comes to onboarding with any API, expanding the number
      of API paths an application puts to work. Modern approaches to producing API
      documentation have moved beyond a single static version of documentation simply
      published to a portal, as well as there being potentially multiple forms of
      documentation for any single API. Helping API producers onboard consumers easier,
      reducing the cognitive load when understanding what an API does, and properly
      defining specific business use cases of an API being put to work in an application
      or as part of an integration.
    elements:
    - name: Reference Documentation
      label: Reference Documentation
      context: 1
  - label: Testing
    image: images/lifecycle-arrow-test.png
    description: A test-driven API lifecycle ensures that each API delivers the intended
      outcomes it was developed for in the first place, providing manual as well as
      automated ways to ensure an API hasn't changed unexpectedly and is as performant
      as required, helping establish a high quality of service consistently across
      all APIs. API testing should not be an afterthought and should be a default
      aspect of the API lifecycle for any API being put into production. API testing
      takes a solid investment in establishing proper testing practices across teams,
      but once you do the work to establish a baseline of testing, properly train
      teams on the process and tooling involved, the investment will pay off down
      the road.
    elements:
    - name: Contract Testing
      label: Contract Testing
      context: 1
    - name: Performance Testing
      label: Performance Testing
      context: 1
  - label: Secure
    image: images/lifecycle-arrow-test.png
    description: Security must be its own area of the API lifecycle, but it is something
      that should span testing, authentication, and potentially other areas of the
      API lifecycle. Over the last five years, the world of API security has expanded,
      while also moving further left in the API lifecycle as part of an operations
      shift in how APIs are delivered. There are a number of elements present when
      it comes to security, but depending on the overall maturity of API operations
      the available resources and prioritization available to adequately realize these
      elements vary.
    elements:
    - name: Authentication
      label: Authentication
      context: 1
    - name: Security Testing
      label: Security Testing
      context: 1
  - label: Monitor
    image: images/lifecycle-arrow-monitor.png
    description: Monitors can be used to execute any Postman collection applied to
      any environment. Due to the versatility of what a Postman collection can define,
      collections turn monitors into powerful API automation and orchestration tool.
      Beginning with the ability to schedule contract, performance, and other types
      of tests, but then also allowing for automating specific workflows across many
      different APIs. Since collections can be used to define anything that can be
      defined via an API, monitors can be used to schedule the running of each capability
      from multiple cloud regions, applying many different environmental variables.
      Making monitors an essential, versatile, and executable part of defining how
      the API lifecycle works.
    elements:
    - name: Contract Testing Monitor
      label: Contract Testing Monitor
      context: 1
    - name: Performance Testing Monitor
      label: Performance Testing Monitor
      context: 1
    - name: Security Testing Monitor
      label: Security Testing Monitor
      context: 1
  - label: Discovery
    image: images/lifecycle-arrow-discover.png
    description: The ability to discover APIs at all states of the API lifecycle is
      essential for reducing redundancy across operations, helping teams find existing
      APIs before they develop new ones, properly matching API consumers with the
      right APIs, while supporting documentation, relevant workflows, and the feedback
      loops that exist as part of the operation of APIs internally within the enterprise,
      or externally with 3rd party developers. API discovery does not live at the
      beginning of the end of the API lifecycle, but should be considered across all
      areas of the API lifecycle, ensuring that APIs, as well as the operations around
      them, are as discoverable as possible, but well informed when it comes to privacy,
      security, and terms of service.
    elements:
    - name: Search
      label: Search
      context: 1
    - name: Private Network
      label: Private Network
      context: 1
    - name: Public Network
      label: Public Network
      context: 1
  discussion: https://github.com/postman-open-technologies/lifecycle/discussions/15
  yaml: https://github.com/postman-open-technologies/lifecycle/blob/main/_blueprints/generate-openapi-from-code-annotations.md
- name: High-Level API Governance
  version: '2021-09-12'
  description: A blueprint for approaching the governance of APIs from the top-down,
    establishing a higher-level strategy for defining what governance is and then
    helping spread guidance across teams that helps enable them to deliver more consistent
    APIs across a more consistent API lifecycle no matter what type of API they are
    delivering.
  collection_id: 12959542-154eeef0-faa5-4c72-828b-ab4e149fbabd
  image: images/blueprints/high-level-api-governance.jpeg
  tags:
  - Governance
  roles:
  - Architect
  - CIO
  - CISO
  - CTO
  - Engineering
  - Product
  - Security  
  state: Ready for Use
  type: Governance
  maturity: Optimized
  level: 370
  areas:
  - label: Define
    description: API governance needs to be well-defined, beginning with defining
      the overall API lifecycle, which this project is dedicated to doing, and the
      establishment of a formal strategy. Without properly defining what governance
      is, and how it will be applied across the API lifecycle, it will never be realized.
      To establish API governance at the highest levels within an organization you
      need a well-defined view of what is happening today across operations, and coherent
      articulation of where we should be going. This definition will not ever be complete,
      but more of an ongoing journey for an organization to define itself.
    image: images/lifecycle-arrow-define.png
    elements:
    - name: API Lifecycle
      label: API Lifecycle
    - name: Governance Strategy
      label: Governance Strategy
  - label: Organization
    image: images/lifecycle-arrow-design.png
    description: The structure and leadership of governance will need to be established
      for API governance to move forward at the highest levels, otherwise, it will
      just be a low-level vision that a handful of teams are able to realize. The
      organization of governance needs to reflect the organization where it is being
      applied in order to have the greatest impact. To do this, you have to invest
      resources, time, and people to help organize, lead and guide teams in learning
      about, understanding, applying, reporting, and providing feedback on what is
      working and what is not working when it comes to governance.
    elements:
    - name: Governance Structure
      label: Governance Structure
    - name: Governance Leadership
      label: Governance Leadership
    - name: Governance Guidelines
      label: Governance Guidelines
  - label: Rules
    image: images/lifecycle-arrow-document.png
    description: API governance rules codify what API governance is as it is applied
      as part of the design, development, and build process on the ground floor of
      API operations. Rules provide the benchmark for what governance is across teams,
      and provide an artifact that can be applied across the API lifecycle by individual
      designers and developers, and eventually baked into the pipelines that move
      API infrastructure forward. Rules should reflect what is happening on the ground
      today, but apply enforcement as part of a forward motion, acknowledging that
      legacy APIs may not always rise to the level of governance and organization
      is moving towards.
    elements:
    - name: Design Rules
      label: Design Rules
    - name: Documentation Rules
      label: Documentation Rules
    - name: Management Rules
      label: Management Rules
    - name: Testing Rules
      label: Testing Rules
  - label: Reports
    image: images/lifecycle-arrow-monitor.png
    description: Reporting on the realities and outcomes of API governance across
      the API lifecycle is needed to make it more visual and tangible for everyone
      involved. Reporting across governance being applied to individual APIs, groups
      of APIs, and overall operations can be realized as part of native platform reporting,
      customized, localized, or in aggregate with Postman Visualizer, or made seamless
      with existing operations by piping data into APM and other systems to make available
      for reporting and visualizations via dashboards.
    elements:
    - name: Reports
      label: Reports
    - name: Visualizer
      label: Visualizer
    - name: APM
      label: APM
  discussion: https://github.com/postman-open-technologies/lifecycle/discussions/45
  yaml: https://github.com/postman-open-technologies/lifecycle/blob/main/_blueprints/low-level-governance.md
- name: Import WSDL for an Existing SOAP Web Service
  version: '2021-09-11'
  description: " This is a blueprint for entering a standardized API lifecycle using
    a WSDL for an existing web service, acknowledging that SOAP still has its place
    in many enterprise Environment, but a common API lifecycle including documentation,
    testing, and other elements is still needed."
  collection_id: 12959542-618c18dc-4f97-42c6-817c-24fb667b3c20
  image: images/blueprints/import-wsdl-for-an-existing-soap-web-service.png
  conclusion:
  tags:
  - WSDL
  - SOAP
  roles:
  - Advocate
  - Architect
  - Backend
  - Operations
  - Engineering
  - Product
  - Support
  - Writer  
  state: Ready for Use
  type: Web Services
  maturity: Foundational
  level: 220
  areas:
  - label: Define
    image: images/lifecycle-arrow-define.png
    description: For traditional web services, the web services description language
      (WSDL) is the key to defining and understanding what each API is capable of.
      Similar to an OpenAPI, the WSDL describes the surface area of a SOAP web service,
      defining the available methods and payload structure. Upon import or creation
      of a new API using WSDL, a modern API lifecycle can be set into motion through
      the generation of collections for documenting and testing web services. Helping
      modernize existing web services by applying some of the common elements of modern
      API lifecycle to existing WSDL services.
    elements:
    - name: Team Workspace
      label: Team Workspace
      context: 1
    - name: Team Members
      label: Team Members
      context: 1
    - name: WSDL
      label: WSDL
  - label: Document
    image: images/lifecycle-arrow-document.png
    description: Having complete, accurate, and easy-to-follow documentation is essential
      for all APIs and is something that alleviates the number one pain point for
      API consumers when it comes to onboarding with any API, expanding the number
      of API paths an application puts to work. Modern approaches to producing API
      documentation have moved beyond a single static version of documentation simply
      published to a portal, as well as there being potentially multiple forms of
      documentation for any single API. Helping API producers onboard consumers easier,
      reducing the cognitive load when understanding what an API does, and properly
      defining specific business use cases of an API being put to work in an application
      or as part of an integration.
    elements:
    - name: Reference Documentation
      label: Reference Documentation
      context: 1
  - label: Testing
    image: images/lifecycle-arrow-test.png
    description: A test-driven API lifecycle ensures that each API delivers the intended
      outcomes it was developed for in the first place, providing manual as well as
      automated ways to ensure an API hasn't changed unexpectedly and is as performant
      as required, helping establish a high quality of service consistently across
      all APIs. API testing should not be an afterthought and should be a default
      aspect of the API lifecycle for any API being put into production. API testing
      takes a solid investment in establishing proper testing practices across teams,
      but once you do the work to establish a baseline of testing, properly train
      teams on the process and tooling involved, the investment will pay off down
      the road.
    elements:
    - name: Contract Testing
      label: Contract Testing
      context: 1
    - name: Performance Testing
      label: Performance Testing
      context: 1
  - label: Secure
    image: images/lifecycle-arrow-test.png
    description: Security must be its own area of the API lifecycle, but it is something
      that should span testing, authentication, and potentially other areas of the
      API lifecycle. Over the last five years, the world of API security has expanded,
      while also moving further left in the API lifecycle as part of an oerations
      shift in how APIs are delivered. There are a number of elements present when
      it comes to security, but depending on the overall maturity of API operations
      the available resources and prioritization available to adequately realize these
      elements vary.
    elements:
    - name: Authentication
      label: Authentication
      context: 1
    - name: Security Testing
      label: Security Testing
      context: 1
  - label: Monitor
    image: images/lifecycle-arrow-monitor.png
    description: Monitors can be used to execute any Postman collection applied to
      any environment. Due to the versatility of what a Postman collection can define,
      collections turn monitors into powerful API automation and orchestration tool.
      Beginning with the ability to schedule contract, performance, and other types
      of tests, but then also allowing for automating specific workflows across many
      different APIs. Since collections can be used to define anything that can be
      defined via an API, monitors can be used to schedule the running of each capability
      from multiple cloud regions, applying many different environmental variables.
      Making monitors an essential, versatile, and executable part of defining how
      the API lifecycle works.
    elements:
    - name: Contract Testing Monitor
      label: Contract Testing Monitor
      context: 1
    - name: Performance Testing Monitor
      label: Performance Testing Monitor
      context: 1
    - name: Security Testing Monitor
      label: Security Testing Monitor
      context: 1
  - label: Discovery
    image: images/lifecycle-arrow-discover.png
    description: The ability to discover APIs at all states of the API lifecycle is
      essential for reducing redundancy across operations, helping teams find existing
      APIs before they develop new ones, properly matching API consumers with the
      right APIs, while supporting documentation, relevant workflows, and the feedback
      loops that exist as part of the operation of APIs internally within the enterprise,
      or externally with 3rd party developers. API discovery does not live at the
      beginning of the end of the API lifecycle, but should be considered across all
      areas of the API lifecycle, ensuring that APIs, as well as the operations around
      them, are as discoverable as possible, but well informed when it comes to privacy,
      security, and terms of service.
    elements:
    - name: Search
      label: Search
      context: 1
    - name: Private Network
      label: Private Network
      context: 1
  discussion: https://github.com/postman-open-technologies/lifecycle/discussions/32
  yaml: https://github.com/postman-open-technologies/lifecycle/blob/main/_blueprints/import-wsdl-for-an-existing-soap-web-service.md
- name: Internal Landscape Mapping
  version: '2021-12-06'
  description: A blueprint for helping jumpstart a mapping of the internal API landscape,
    allowing an organization to begin getting a handle on what is happening across
    operations. Beginning by profiling a specific group or domain, but then expanding
    it across operations once a portion of the landscape has been mapped and understood.
  image: images/blueprints/internal-landscape-mapping.jpeg
  conclusion: Text
  tags:
  - Groups
  - Teams
  - Roles
  - Domains
  roles:
  - Advocate
  - Architect
  - CIO
  - CISO
  - CTO
  - Engineering
  - Product
  - Operations  
  state: Ready for Use
  type: Base
  maturity: Foundational
  level: 140
  areas:
  - label: Team
    description: Understanding the makeup of the teams behind the development of APIs
      is an essential part of moving APIs forward at scale across an organization.
      Mapping out the team landscape can begin in three areas, with efforts focusing
      on a single group and the members and roles that exist within that single group,
      before expanding to other teams. Working to make sure that the current state
      of teams is mapped out, but then establishing an apparatus that will accommodate
      the future of development by mapping out three key areas.
    image: images/lifecycle-arrow-define.png
    elements:
    - name: Team Groups
      label: Team Groups
    - name: Team Members
      label: Team Members
    - name: Team Roles
      label: Team Roles
  - label: APIs
    description: Mapping the API landscape is required to get a handle on API operations,
      and allow business and technical leadership to assert the observability and
      control they need to move things forward. Until all APIs are mapped out, documented,
      and made discoverable, you will not be able to effectively evolve APIs, and
      there will always be redundancy in the API infrastructure behind web, mobile,
      and device applications. Mapping of the enterprise API landscape begins with
      documentation for each API but then focuses on the artifacts that are increasingly
      defining them.
    image: images/lifecycle-arrow-define.png
    elements:
    - name: Documentation
      label: Documentation
    - name: Swagger
      label: Swagger
    - name: OpenAPI
      label: OpenAPI
  - label: Workspace
    description: Understanding where work on API is occurring is needed to be able
      to standardize, observe, and govern the API development process. API workspaces
      are where you will find the artifacts developers are using to design, develop,
      and sustain APIs, and provide what is needed to observe operations, but then
      also begin to steer things in any particular direction. These are the common
      elements where you will find work occurring on APIs, and are where leadership
      should look for what is needed to observe operations and move things forward.
    image: images/lifecycle-arrow-define.png
    elements:
    - name: Team Workspace
      label: Team Workspace
    - name: Github Repository
      label: Github Repository
  discussion: ''
  yaml: ''
  collection_id: 12959542-98ffae74-9c86-4df4-92f8-624b711084f5
- name: Low Level API Governance
  version: '2021-09-12'
  description: A blueprint for approaching the governance of APIs beginning with each
    individual API by individual developers, setting API governance into motion at
    the lowest level by a single or group of developers, acknowledging that governance
    will only get you so far at this level, but in many organizations, it might sense
    to start at this level.
  collection_id: 12959542-92aeade8-8095-4e24-adb5-9e789266e3e3
  image: images/blueprints/low-level-api-governance.jpeg
  tags:
  - Governance
  roles:
  - Advocate
  - Architect
  - Backend
  - Operations
  - Engineering
  - Product  
  state: Ready for Use
  type: Governance
  maturity: Optimized
  level: 230
  areas:
  - label: Definition
    description: You can't govern what you don't have defined, and to be able to begin
      governing the design of your APIs you will need to have machine-readable artifacts
      that you can lint as part of the design, development, or build process. Establishing
      a set of artifacts that help drive the API lifecycle, but also make it something
      that can be measured and reported upon as part of governance activities.
    image: images/lifecycle-arrow-define.png
    elements:
    - name: OpenAPI
      label: OpenAPI
    - name: AsyncAPI
      label: AsyncAPI
  - label: Applications
    image: images/lifecycle-arrow-design.png
    description: Once you have an OpenAPI, AsyncAPI, or other artifacts that you would
      like to apply governance, there are a handful of ways in which you can execute
      governance as part of your regular work. Depending on your goals with governing
      the design of an API you can apply each of these elements helping manual or
      automatically identify problems with the design of your API. These approaches
      to execution are potentially dependent on other rules, as well as the approach
      you take to automating the application of governance.
    elements:
    - name: Rules-Based Linting
      label: Rules-Based Linting
    - name: Script-Based Governance
      label: Script-Based Governance
  - label: Rules
    image: images/lifecycle-arrow-document.png
    description: API governance rules codify what API governance is as it is applied
      as part of the design, development, and build process on the ground floor of
      API operations. Rules provide the benchmark for what governance is across teams,
      and provide an artifact that can be applied across the API lifecycle by individual
      designers and developers, and eventually baked into the pipelines that move
      API infrastructure forward. Rules should reflect what is happening on the ground
      today, but apply enforcement as part of a forward motion, acknowledging that
      legacy APIs may not always rise to the level of governance and organization
      is moving towards.
    elements:
    - name: Info Governance Rules
      label: Info Governance Rules
    - name: Contact Governance Rules
      label: Contact Governance Rules
    - name: Versioning Governance Rules
      label: Versioning Governance Rules
    - name: Path Governance Rules
      label: Path Governance Rules
    - name: Operations Governance Rules
      label: Operations Governance Rules
    - name: Parameter Governance Rules
      label: Parameter Governance Rules
    - name: Request Bodies Governance Rules
      label: Request Bodies Governance Rules
    - name: Response Governance Rules
      label: Response Governance Rules
    - name: Schema Governance Rules
      label: Schema Governance Rules
    - name: Tags Governance Rules
      label: Tags Governance Rules
  - label: Automation
    image: images/lifecycle-arrow-test.png
    description: To realize governance across operations it is important that governance
      is applied in automated ways at different areas of the API lifecycle, helping
      ensure API governance can be applied early on in the lifecycle but is also available
      throughout the development and delivery of APIs, and when it makes sense bake
      it into the build process ensuring that governance is applied by default as
      every API moves into production. Helping ensure that teams aren't doing extra
      work to realize governance across operations, and it is just at their fingertips
      as they are designed, developing, and building APIs as part of their regular
      day.
    elements:
    - name: Design Time Governance
      label: Design Time Governance
    - name: Collection Governance
      label: Collection Governance
    - name: CLI Governance
      label: CLI Governance
    - name: IDE Governance
      label: IDE Governance
    - name: Pipeline Governance
      label: Pipeline Governance
  - label: Reports
    image: images/lifecycle-arrow-monitor.png
    description: Reporting on the realities and outcomes of API governance across
      the API lifecycle is needed to make it more visual and tangible for everyone
      involved. Reporting across governance being applied to individual APIs, groups
      of APIs, and overall operations can be realized as part of native platform reporting,
      customized, localized, or in aggregate with Postman Visualizer, or made seamless
      with existing operations by piping data into APM and other systems to make available
      for reporting and visualizations via dashboards.
    elements:
    - name: Reports
      label: Reports
    - name: Visualizer
      label: Visualizer
    - name: APM
      label: APM
  discussion: https://github.com/postman-open-technologies/lifecycle/discussions/44
  yaml: https://github.com/postman-open-technologies/lifecycle/blob/main/_blueprints/low-level-governance.md
- name: Manually Define Collection for Existing API
  version: '2021-09-11'
  description: This is a blueprint for how to manually create a collection for an
    existing API, transferring details of each request from documentation to a collection,
    applying authentication, then continuing to explore and troubleshoot until you
    have a complete and documented collection for an API.
  collection_id: 12959542-8769f222-c46b-413c-a7fb-b642254a9d6c
  image: images/blueprints/manually-define-collection-for-existing-api.jpeg
  tags:
  - Collections
  - Existing
  roles:
  - Advocate
  - Architect
  - Backend
  - Operations
  - Engineering
  - Frontend
  - Mobile
  - Product
  - Support
  - Writer  
  state: Ready for Use
  type: Definitions
  maturity: Foundational
  level: 110
  areas:
  - label: Define
    image: images/lifecycle-arrow-define.png
    description: The Postman collection has become a proven solution for defining
      and troubleshooting existing APIs over the last five years. Providing a machine-readable
      representation of the details of each API request and response that can then
      be used as an API client, to power documentation and testing. Postman collections
      provide an ideal foundation for defining what an API can do, then using that
      collection to power other stops along the API lifecycle, be shared internally
      via other workspaces, and externally via workspaces, URL, or an embeddable Run
      in Postman button. Providing an industrial-strength approach to laying a foundation
      for a repeatable and well-known API lifecycle for an existing API that is already
      in production.
    elements:
    - name: Collection
      label: Collection
  - label: Document
    image: images/lifecycle-arrow-document.png
    description: Having complete, accurate, and easy-to-follow documentation is essential
      for all APIs and is something that alleviates the number one pain point for
      API consumers when it comes to onboarding with any API, expanding the number
      of API paths an application puts to work. Modern approaches to producing API
      documentation have moved beyond a single static version of documentation simply
      published to a portal, as well as there being potentially multiple forms of
      documentation for any single API. Helping API producers onboard consumers easier,
      reducing the cognitive load when understanding what an API does, and properly
      defining specific business use cases of an API being put to work in an application
      or as part of an integration.
    elements:
    - name: Reference Documentation
      label: Reference Documentation
      context: 1
  - label: Testing
    image: images/lifecycle-arrow-test.png
    description: A test-driven API lifecycle ensures that each API delivers the intended
      outcomes it was developed for in the first place, providing manual as well as
      automated ways to ensure an API hasn't changed unexpectedly and is as performant
      as required, helping establish a high quality of service consistently across
      all APIs. API testing should not be an afterthought and should be a default
      aspect of the API lifecycle for any API being put into production. API testing
      takes a solid investment in establishing proper testing practices across teams,
      but once you do the work to establish a baseline of testing, properly train
      teams on the process and tooling involved, the investment will pay off down
      the road.
    elements:
    - name: Contract Testing
      label: Contract Testing
      context: 1
    - name: Performance Testing
      label: Performance Testing
      context: 1
  - label: Secure
    image: images/lifecycle-arrow-test.png
    description: Security must be its own area of the API lifecycle, but it is something
      that should span testing, authentication, and potentially other areas of the
      API lifecycle. Over the last five years, the world of API security has expanded,
      while also moving further left in the API lifecycle as part of an operations
      shift in how APIs are delivered. There are a number of elements present when
      it comes to security, but depending on the overall maturity of API operations
      the available resources and prioritization available to adequately realize these
      elements vary.
    elements:
    - name: Authentication
      label: Authentication
      context: 1
    - name: Security Testing
      label: Security Testing
      context: 1
  - label: Monitor
    image: images/lifecycle-arrow-monitor.png
    description: Monitors can be used to execute any Postman collection applied to
      any environment. Due to the versatility of what a Postman collection can define,
      collections turn monitors into powerful API automation and orchestration tool.
      Beginning with the ability to schedule contract, performance, and other types
      of tests, but then also allowing for automating specific workflows across many
      different APIs. Since collections can be used to define anything that can be
      defined via an API, monitors can be used to schedule the running of each capability
      from multiple cloud regions, applying many different environmental variables.
      Making monitors an essential, versatile, and executable part of defining how
      the API lifecycle works.
    elements:
    - name: Contract Testing Monitor
      label: Contract Testing Monitor
      context: 1
    - name: Performance Testing Monitor
      label: Performance Testing Monitor
      context: 1
    - name: Security Testing Monitor
      label: Security Testing Monitor
      context: 1
  - label: Discovery
    image: images/lifecycle-arrow-discover.png
    description: The ability to discover APIs at all states of the API lifecycle is
      essential for reducing redundancy across operations, helping teams find existing
      APIs before they develop new ones, properly matching API consumers with the
      right APIs, while supporting documentation, relevant workflows, and the feedback
      loops that exist as part of the operation of APIs internally within the enterprise,
      or externally with 3rd party developers. API discovery does not live at the
      beginning or the end of the API lifecycle, but should be considered across all
      areas of the API lifecycle, ensuring that APIs, as well as the operations around
      them, are as discoverable as possible, but well informed when it comes to privacy,
      security, and terms of service.
    elements:
    - name: Search
      label: Search
      context: 1
    - name: Private Network
      label: Private Network
      context: 1
    - name: Public Network
      label: Public Network
      context: 1
  discussion: https://github.com/postman-open-technologies/lifecycle/discussions/13
  yaml: https://github.com/postman-open-technologies/lifecycle/blob/main/_blueprints/manually-define-collection-for-an-existing-api.md
- name: New API Using the AsyncAPI Specification
  version: '2021-09-11'
  description: This is a blueprint to try and define a new event-driven API using
    AsyncAPI, pushing the boundaries of this API lifecycle blueprint to include multiple
    protocols, patterns, and ensuring that there can be a well-defined API lifecycle
    across a diverse set of approaches to delivering APIs.
  collection_id: 12959542-d50ab7cf-eeb9-4b1e-b8e8-b17e8a2b6cd6
  image: images/blueprints/new-api-using-the-asyncapi-specification.jpeg
  conclusion: ''
  tags:
  - New
  - AsyncAPI
  roles:
  - Nobody  
  state: Ready for Use
  type: New
  maturity: Optimized
  level: 350
  areas:
  - label: Define
    image: images/lifecycle-arrow-define.png
    description: Ensuring that operations supporting an API are properly defined,
      as well as what is needed to properly design and bring an API to life. A little
      planning and organization at this step of an APIs journey can go a long way
      towards ensuring the overall health and velocity of an API, and the applications
      that depend on this internal, partner, or public API.
    elements:
    - name: Use Cases
      label: Use Cases
    - name: Schema
      label: Schema
    - name: Events
      label: Events
    - name: Applications
      label: Applications
  - label: Develop
    image: images/lifecycle-arrow-deploy.png
    description: Provide a mock for the API.
    elements:
    - name: Code
      label: Code
    - name: Business Logic
      label: Business Logic
  - label: Operate
    description: Operate an API in production.
    image: images/lifecycle-arrow-manage.png
    elements:
    - name: Deploy
      label: Deploy
    - name: Secure
      label: Secure
    - name: Audit
      label: Audit
    - name: Monitor
      label: Monitor
    - name: Inform
      label: Inform
  - label: Discovery
    image: images/lifecycle-arrow-discover.png
    description: Discovery involving an API.
    elements:
    - name: Events
      label: Events
    - name: Relationships
      label: Relationships
  discussion: https://github.com/postman-open-technologies/lifecycle/discussions/19
  yaml: https://github.com/postman-open-technologies/lifecycle/blob/main/_blueprints/new-api-using-the-asyncapi-specification.md
- name: New API Using the OpenAPI Specification
  version: '2021-09-11'
  description: This provides a blueprint for beginning the API lifecycle by designing
    a new API using an OpenAPI, showing one possible lifecycle from end to end. Approaching
    the API lifecycle in a design-first way, while ensuring all the other essential
    areas of the API lifecycle are present.
  collection_id: 12959542-3d82f93a-adc1-45d6-9d6c-7362f4cc0c65
  image: images/blueprints/new-api-using-the-openapi-specification.jpg
  tags:
  - OpenAPI
  - New
  roles:
  - Advocate
  - Architect
  - Backend
  - Operations
  - Engineering
  - Frontend
  - Mobile
  - Product  
  state: Ready for Use
  type: New
  maturity: Foundational
  level: 210
  areas:
  - label: Define
    description: The most important first step of any API lifecycle is to make sure
      the operations around an API are properly defined, laying the foundation for
      being able to effectively design and bring an API to life, while also establishing
      a known place, or places to go to get all the information you need regarding
      each individual API or groups of APIs. A little planning and organization at
      this early step of the API journey can go a long way towards ensuring the overall
      health and velocity of an API, and the applications and integrations that will
      depend on each internal, partner, or public API being delivered.
    image: images/lifecycle-arrow-define.png
    elements:
    - name: Team Workspace
      label: Team Workspace
      context: 1
    - name: Team Members
      label: Team Members
      context: 1
    - name: Github Repository
      label: Github Repository
      context: 1
  - label: Design
    image: images/lifecycle-arrow-design.png
    description: Having a formal process and approach to designing an API helps establish
      consistency and the precision of each API that ends up in production, ensuring
      that APIs are developed using common patterns across an industry, and within
      an organization, establishing known practices for shaping the surface area and
      behaviors of APIs that applications are depending upon. API design is something
      that just doesnt impact the way an API is used, it is something that impacts
      almost every stop along the API lifecycle, and will reduce friction and increase
      velocity throughout the evolution of each API, and the applications and integrations
      that depend upon them.
    elements:
    - name: OpenAPI
      label: OpenAPI
      context: 1
  - label: Mock
    image: images/lifecycle-arrow-mock.png
    description: Mocking how an API works and behaves provides an effective way for
      teams to collaborate, communicate, and iterate as part of the design of an API,
      but it also is something that can be used as part of testing, or just providing
      a sandbox environment for API consumers to learn before they actually begin
      working with any API in production. Effectively mocking an API takes a little
      time to set up and configure properly, but once available it will help reduce
      friction across the entire API lifecycle, helping teams more effectively communicate
      around an API throughout its journey.
    elements:
    - name: Mock Server
      label: Mock Server
      context: 1
    - name: Examples
      label: Examples
      context: 1
  - label: Document
    image: images/lifecycle-arrow-document.png
    description: Having complete, accurate, and easy-to-follow documentation is essential
      for all APIs and is something that alleviates the number one pain point for
      API consumers when it comes to onboarding with any API, expanding the number
      of API paths an application puts to work. Modern approaches to producing API
      documentation have moved beyond a single static version of documentation simply
      published to a portal, as well as there being potentially multiple forms of
      documentation for any single API. Helping API producers onboard consumers easier,
      reducing the cognitive load when understanding what an API does, and properly
      defining specific business use cases of an API being put to work in an application
      or as part of an integration.
    elements:
    - name: Reference Documentation
      label: Reference Documentation
      context: 1
  - label: Deploy
    image: images/lifecycle-arrow-deploy.png
    description: Establishing a well-defined process to deploy an API helps teams
      bring new APIs to life, as well as assists them in more efficiently delivering
      each future iteration of an API in a consistent and repeatable way. Ensuring
      APIs are deployed using known development, staging, production, and other agreed-upon
      states that actively apply other elements like documentation, testing, while
      natively contributing to observability. API deployment practices will likely
      have been well established as part of an organizations traditional software
      development lifecycle but are something that should be open to defining, standardizing,
      and making more repeatable and observable as part of the API lifecycle. The
      API deployment portion of the API lifecycle will be the most difficult for teams
      to properly define, articulate, and standardize across teams, but it will continue
      to be one of the most critical areas of the API lifecycle to do this for, otherwise,
      it will be guaranteed to be a repeated source of friction across API operations.
    elements:
    - name: CI/CD Pipeline
      label: CI/CD Pipeline
      context: 1
    - name: Gateway
      label: Gateway
      context: 1
  - label: Manage
    image: images/lifecycle-arrow-manage.png
    description: APIs should always be managed using a set of a common, well-defined
      set of policies that define and govern how APIs are accessed via all states
      of the API lifecycle, ensuring that every API has appropriate authentication,
      rate limits, logging, and other essential requirements of managing APIs at scale,
      helping strike a balance between making APIs accessible and the privacy and
      security concerns that exist. As API gateways and management solutions have
      been commoditized, many of the essential elements like documentation and testing
      have expanded into their own areas of the API lifecycle, leaving us with a core
      set of elements that can be applied by teams to help manage how APIs are put
      to work in applications and as part of system to system integrations.
    elements:
    - name: Onboarding
      label: Onboarding
      context: 1
    - name: Usage Plan
      label: Usage Plan
      context: 1
    - name: Key
      label: Key
      context: 1
  - label: Testing
    image: images/lifecycle-arrow-test.png
    description: A test-driven API lifecycle ensures that each API delivers the intended
      outcomes it was developed for in the first place, providing manual as well as
      automated ways to ensure an API hasn't changed unexpectedly and is as performant
      as required, helping establish a high quality of service consistently across
      all APIs. API testing should not be an afterthought and should be a default
      aspect of the API lifecycle for any API being put into production. API testing
      takes a solid investment in establishing proper testing practices across teams,
      but once you do the work to establish a baseline of testing, properly train
      teams on the process and tooling involved, the investment will pay off down
      the road.
    elements:
    - name: Contract Testing
      label: Contract Testing
      context: 1
    - name: Performance Testing
      label: Performance Testing
      context: 1
  - label: Secure
    image: images/lifecycle-arrow-test.png
    description: Security must be its own area of the API lifecycle, but it is something
      that should span testing, authentication, and potentially other areas of the
      API lifecycle. Over the last five years, the world of API security has expanded,
      while also moving further left in the API lifecycle as part of an operations
      shift in how APIs are delivered. There are a number of elements present when
      it comes to security, but depending on the overall maturity of API operations
      the available resources and prioritization available to adequately realize these
      elements vary.
    elements:
    - name: Authentication
      label: Authentication
      context: 1
    - name: Security Testing
      label: Security Testing
      context: 1
  - label: Monitor
    image: images/lifecycle-arrow-monitor.png
    description: Monitors can be used to execute any Postman collection applied to
      any environment. Due to the versatility of what a Postman collection can define,
      collections turn monitors into powerful API automation and orchestration tool.
      Beginning with the ability to schedule contract, performance, and other types
      of tests, but then also allowing for automating specific workflows across many
      different APIs. Since collections can be used to define anything that can be
      defined via an API, monitors can be used to schedule the running of each capability
      from multiple cloud regions, applying many different environmental variables.
      Making monitors an essential, versatile, and executable part of defining how
      the API lifecycle works.
    elements:
    - name: Contract Testing Monitor
      label: Contract Testing Monitor
      context: 1
    - name: Performance Testing Monitor
      label: Performance Testing Monitor
      context: 1
    - name: Security Testing Monitor
      label: Security Testing Monitor
      context: 1
  - label: Discovery
    image: images/lifecycle-arrow-discover.png
    description: The ability to discover APIs at all states of the API lifecycle is
      essential for reducing redundancy across operations, helping teams find existing
      APIs before they develop new ones, properly matching API consumers with the
      right APIs, while supporting documentation, relevant workflows, and the feedback
      loops that exist as part of the operation of APIs internally within the enterprise,
      or externally with 3rd party developers. API discovery does not live at the
      beginning or the end of the API lifecycle, but should be considered across all
      areas of the API lifecycle, ensuring that APIs, as well as the operations around
      them, are as discoverable as possible, but well informed when it comes to privacy,
      security, and terms of service.
    elements:
    - name: Search
      label: Search
      context: 1
    - name: Private Network
      label: Private Network
      context: 1
    - name: Public Network
      label: Public Network
      context: 1
  - label: End of Life
    image: images/lifecycle-arrow-retire.png
    description: Having a plan for the eventual retirement and ultimate deprecation
      of an API, or for specific paths or versions of an API should be a part of every
      API lifecycle, and even when there is no plan for deprecation there should be
      a process in place for setting consumer expectations for how long an API will
      be supported, as well as a formal process to follow once retirement comes into
      view on the horizon. Planning for the end of life of each API will be commonplace,
      but only becomes a problem when there is no plan, or no communication with consumers.
    elements:
    - name: Retire
      label: Retire
      context: 1
    - name: Deprecate
      label: Deprecate
      context: 1
  discussion: https://github.com/postman-open-technologies/lifecycle/discussions/9
  yaml: https://github.com/postman-open-technologies/lifecycle/blob/main/_blueprints/new-api-using-the-openapi-specification.md
- name: Bringing More Observability to Operations
  version: '2021-11-24'
  description: API observability involves being able to tap the existing outputs of
    our operations to understand the current state of the enterprise system across
    all teams. Being able to perpetually monitor, but also be able to see the health,
    history, and activity across APIs, but also the operations surrounding those APIs,
    allows us to observe things at a micro or macro level.
  collection_id: 12959542-11679b12-fb87-4398-921f-6d9cd45a6b53
  image: images/blueprints/bringing-more-observability-to-operations.jpeg
  tags:
  - Observability
  roles:
  - Advocate
  - Architect
  - Operations
  - Engineering
  - Product
  - CIO
  - CISO
  - CTO  
  state: Work in Progress
  type: Observability
  maturity: Optimized
  level: 320
  areas:
  - label: Team
    description: When you operate on an API platform everything has outputs, including
      your teams. The teams behind API operations can be added to the resources and
      capabilities you are observing as part of regular activities. Tapping into the
      APIs and other outputs behind API teams, individual members, the groups they
      are organized into, and the role-based access control that is applied to teams.
      Observability at the team layer helps build awareness regarding what teams are
      up to, what APIs they are working on, and provides us with models for what healthy
      teams look like and what not so healthy teams look like, allowing us to better
      understand what works and what doesn't in real-time.
    image: images/lifecycle-arrow-define.png
    elements:
    - name: Members
      label: Members
    - name: Groups
      label: Groups
    - name: Role Based Access Control (RBAC)
      label: Role Based Access Control (RBAC)
  - label: Workspace
    description: Observability at the workspace level is the window to the API factory
      floor today. Workspaces are where teams are iterating upon their APIs, then
      generating and managing collections for their mock servers, documentation, and
      testing. Like Git Repository have done for the last decade, API workspaces are
      allowing for a more collaborative API lifecycle that is also more natively observable
      with the ability to watch workspaces, but also the history and activity occurring
      across these elements of the API lifecycle. Workspace observability allows us
      to tune into what is happening within a single workspace, but also in aggregate
      across many workspaces, illuminating what is happening across the API factory
      floor each day
    image: images/lifecycle-arrow-define.png
    elements:
    - name: Watch
      label: Watch
    - name: History
      label: History
    - name: Activity
      label: Activity
  - label: APIs
    description: API observability isn't just about monitoring the health of each
      individual API, but also observability into the change that is inevitable around
      APIs. Allowing team members, consumers, and other stakeholders to watch APIs,
      and comment on APIs, allowing them to receive notifications and stay informed
      with the changes occurring around APIs. Observability today starts with the
      availability and health of APIs, but then has rapidly expanded to what is happening
      around each API, or across many APIs, helping bring more depth to the API observability
      that exists across an operation.
    image: images/lifecycle-arrow-define.png
    elements:
    - name: Watch
      label: Watch
    - name: Changes
      label: Changes
    - name: Comments
      label: Comments
  - label: Lifecycle
    description: Since the infrastructure beneath our APIs also has APIs, we can extend
      API observability to the lifecycle moving our APIs forward. Allowing us to observe
      that APIs are discoverable and what APIs team members and the public are searching
      for. Providing us with outputs from defining, designing, developing, and the
      deployment of APIs, adding observability across the API lifecycle using the
      APIs behind our source control, CI/CD, and gateways, offering us the outputs
      needed to wire up the API lifecycle to our application performance management
      (APM) solutions, providing us with unprecedented observability across our operations.
    image: images/lifecycle-arrow-define.png
    elements:
    - name: Discovery
      label: Discovery
    - name: Define
      label: Define
    - name: Design
      label: Design
    - name: Develop
      label: Develop
    - name: Deploy
      label: Deploy
    - name: Observe
      label: Observe
  - label: Reports
    description: One of the essential ingredients in API platform observability is
      the ability to view reports from across the key areas of operations. Reporting
      gives us visual visibility across teams and APIs that allows us to view what
      is happening at the highest level of our operations, but also drill down to
      what is occurring with each team or API. Leveraging our observability to stay
      aware of what is happening across teams and APIs, but also something that contributes
      to overall security across operations by bringing attention to encryption, authentication,
      and the other dimensions of the security across the hundreds or thousands of
      APIs being put to work each day.
    image: images/lifecycle-arrow-define.png
    elements:
    - name: Team
      label: Team
    - name: APIs
      label: APIs
    - name: Security
      label: Security
  - label: Integrations
    description: Because of APIs, observability exists at the integration level of
      the API platforms. Providing observability into the source control, CI/CD, and
      gateway dimensions of our operations. Observability at these foundational aspects
      of how our API operations work or don't work provides the awareness needed to
      understand what is happening across not just the API lifecycle, but also the
      overlapping software development lifecycle (SLDC). This type of observability
      is about optimizing not just single APIs, but optimizing operations across teams
      and domains, providing the observability required to understand things at scale,
      but then also begin to course-correct what is happening at scale.
    image: images/lifecycle-arrow-define.png
    elements:
    - name: Source Control
      label: Source Control
    - name: CI/CD
      label: CI/CD
    - name: Gateway
      label: Gateway
    - name: APM
      label: APM
  discussion: ''
  yaml: ''
- name: Providing Onboarding Collections
  version: '2021-11-24'
  description: Providing collections that are dedicated to onboarding new users with
    an API, helping reduce the cognitive load with understanding what is possible
    across an API, and presenting them with only the most common API paths they will
    need to get started with an API, reducing the time it takes from discovery to
    making their first API call as a new consumer.
  collection_id: 12959542-bd297b8a-9026-42ae-80ec-51b912c9a3cb
  image: images/blueprints/providing-onboarding-collections.png
  tags:
  - Collections
  - Documentation
  roles:
  - Advocate
  - Operations
  - Support
  - Writer  
  state: Work in Progress
  type: Definitions
  maturity: Optimized
  level: 260
  areas:
  - label: Purpose
    description: The versatility and focus of collections are one of the things that
      make them so powerful. One type of collection that takes advantage of the ability
      for collections to become very precise is the observability collection. Providing
      another example of a Postman collection that can have a specific purpose, in
      this case, it is making sure consumers are onboarded as easily as possible.
      Providing a positive first impression, reducing the cognitive load present when
      someone first encounters an API, speeding up the time to first call, and optimizing
      the engagement by consumers. Transforming collections into another very precise
      way for benefitting API operations, contributing to all of it working well.
    image: images/lifecycle-arrow-define.png
    elements:
    - name: First Impression
      label: First Impression
    - name: Cognitive Load
      label: Cognitive Load
    - name: Time to First Call
      label: Time to First Call
    - name: Engagement
      label: Engagement
  - label: Structure
    description: The number of requests should be limited within onboarding collections,
      but the structure of them should maximize the structure of a collection by taking
      full advantage of the collection specification. Helping each granular capability
      to be as full-featured and robust as possible. The power of onboarding goes
      well beyond the limited scope and a more relevant title and description, pushing
      the producer to think about what other affordances can be provided to demonstrate
      what is possible with each set of digital resources,  Helping maximize the functionality,
      but also reduce friction when it comes to getting started with an API, ensuring
      that new API consumers move from discovery and learning about an API to actually
      putting to work in some way in as short of time as possible.
    image: images/lifecycle-arrow-define.png
    elements:
    - name: Authentication
      label: Authentication
    - name: Folders
      label: Folders
    - name: Request
      label: Request
    - name: Examples
      label: Examples
  - label: Environment
    description: Common elements required to run an onboarding collection should be
      abstracted away to an environment. Allowing whoever has forked the capability
      collection to easily define what is needed to authenticate, operate, and maintain
      the state of the requests being executed. Abstract away secrets, tokens, and
      other keys/value pairs that are needed to execute the onboarding collection,
      but also potentially store data that may have been created, altered, and removed
      as part of running each individual resource. Enabling each onboarding collection
      to be powered, but also potentially for many different onboarding collections
      to be executed for a single specific environment.
    image: images/lifecycle-arrow-define.png
    elements:
    - name: states
      label: states
    - name: Variables
      label: Variables
    - name: Authorization Variables
      label: Authorization Variables
  - label: Engagement
    description: Onboarding collections reduce what it takes to engage with each individual
      API resource, but also at the same time it widens the number of ways in which
      consumers can engage. The precision of an onboarding collection is perfect for
      very granular sharing via a URL, embedding within a blog post or on documentation
      using a button, but also allows resources to be forked, and have pull requests
      submitted, and potentially allow for merging of individual details of an API--reducing
      the cognitive load for defining, engaging, and executing each individual API
      resources, but also encouraging contributions from consumers via a single collection.
    image: images/lifecycle-arrow-define.png
    elements:
    - name: Collection URL
      label: Collection URL
    - name: Collection Button
      label: Collection Button
    - name: Collection Watch
      label: Collection Watch
    - name: Collection Fork
      label: Collection Fork
    - name: Collection Pull Request
      label: Collection Pull Request
    - name: Collection Merge
      label: Collection Merge
  discussion: ''
  yaml: ''
- name: Why OpenAPI Matters to Operations
  version: '2021-11-24'
  description: OpenAPI is an open-source specification for describing the surface
    area of HTTP APIs, providing a machine-readable format for describing the details
    of the request and responses, establishing a contract that can be used to generate
    documentation, mock servers, testing, security, code generation, and other essential
    elements of operating APIs across operations.
  collection_id: 12959542-ff83b95b-ec05-464c-997e-886f001dfb53
  image: images/blueprints/why-openapi-matters-to-operations.jpeg
  conclusion: Text
  tags:
  - OpenAPI
  roles:
  - CIO
  - CISO
  - CTO
  - Advocate
  - Architect
  - Backend
  - Operations
  - Engineering
  - Frontend
  - Mobile
  - Product
  - Support
  - Writer  
  state: Work in Progress
  type: Definitions
  maturity: Foundational
  level: 120
  areas:
  - label: Purpose
    description: OpenAPI provides a machine and human-readable contract regarding
      the business value each API delivers. Establishing an artifact that can be used
      to generate mock servers, documentation, tests, and other elements of the API
      lifecycle. Providing guardrails for API operations that provide us with a common
      vocabulary for collectively moving APIs forward at scale in a consistent way,
      giving us something that the machines and humans can make sense of. Acknowledging
      that it takes something to be well defined enough for the computers to get what
      is happening, but also easy enough for humans to make sense of, allows us to
      strike a balance and agreement between the machines and humans about what each
      digital resource and capability will do.
    image: images/lifecycle-arrow-define.png
    elements:
    - name: Machine-Readable Artifact
      label: Machine-Readable Artifact
    - name: Human-Readable Artifact
      label: Human-Readable Artifact
    - name: Lifecycle
      label: Lifecycle
  - label: Objects
    description: OpenAPI provides us with a set of common objects for describing the
      surface area of our HTTP APIs. Giving us the vocabulary for describing the metadata
      around our APIs like the name and description, but also licensing contact, and
      other more human aspects of our APIs. These objects also allow us to get very
      focused on the technical details associated with the surface area of each request,
      response, schema, and the other nitty-gritty nuts and bolts of how APIs work.
      Allowing us to speak in general or very precise terms when it comes to describing
      our APIs, depending on what we will be doing with our OpenAPI definitions across
      the API lifecycle.
    image: images/lifecycle-arrow-define.png
    elements:
    - name: Information
      label: Information
    - name: Contact
      label: Contact
    - name: License
      label: License
    - name: Servers
      label: Servers
    - name: Components
      label: Components
    - name: Paths
      label: Paths
    - name: Operations
      label: Operations
    - name: Request Bodies
      label: Request Bodies
    - name: Responses
      label: Responses
    - name: Examples
      label: Examples
    - name: Schema
      label: Schema
  - label: Usage
    description: OpenAPI is best known for being able to generate API documentation,
      but it is also capable of generating mock servers, tests, security scans, generating
      code, and other essential aspects of operating APIs. OpenAPI is much more than
      just any single end goal of producing a definition for an API, providing the
      machine-readable details needed to guide an API forward as part of the API lifecycle.
      The usage of OpenAPI often depends on how far along an organization and its
      teams are in their API journey, and usually, it begins in service of documentation,
      but then will rapidly expand from there to service other areas of the API lifecycle
      across operations.
    image: images/lifecycle-arrow-define.png
    elements:
    - name: Documentation
      label: Documentation
    - name: Mock Server
      label: Mock Server
    - name: Testing
      label: Testing
    - name: Security
      label: Security
  discussion: ''
  yaml: ''
- name: Community Theatrical Production
  version: '2021-11-24'
  description: When it comes to reaching a community of API consumers it takes just
    the right performance that informs and adds value to their world but also potentially
    entertains them as well. Going well beyond just marketing content and information,
    and providing informative, compelling, and hands-on products are essential to
    reaching and standing out within developer communities.
  collection_id: 12959542-ca099957-5894-495d-9715-b627e1d33f0c
  image: images/blueprints/community-theatrical-production.jpeg
  conclusion: Text
  tags:
  - Devrel
  roles:
  - Advocate  
  state: Work in Progress
  type: Storytelling
  maturity: Optimized
  level: 250
  areas:
  - label: Components
    description: Developer relations and advocacy revolve around a handful of common
      components that get the attention of the community while also providing them
      with valuable information and tooling they can put to work in their work. Individually,
      these components have minimal impact on getting the attention within the community
      and drive engagement with API consumers, but collectively they have the potential
      to bring attention to a specific area or topic. What is more important than
      the attention these components bring, is that the goal is to always make them
      as hands-on as possible, allowing anyone to fork and put to work delivering
      whatever is being present4ed.
    image: images/lifecycle-arrow-define.png
    elements:
    - name: Blog Post
      label: Blog Post
    - name: Video
      label: Video
    - name: Tweet
      label: Tweet
    - name: Workspace
      label: Workspace
    - name: Collection
      label: Collection
  - label: Metrics
    description: A significant part of any production will be actually measuring the
      reach and impact of the performance. There are a number of proven metrics that
      can be used to quantify the reach and impact of the activity that occurs as
      part of any production, helping understand which productions are successful
      and which are not. Providing some metrics that can be turned into to guide future
      research and productions but shouldn't be used as the ultimate measurement of
      success. The goal is to inform the community, and provide them with ways to
      understand what is possible with APIs, and how they can be put o use in applications
      and integrations, while measuring engagement with watches and forks on the hands-on
      APIs and collections included as part of productions.
    image: images/lifecycle-arrow-define.png
    elements:
    - name: Blog Page Views
      label: Blog Page Views
    - name: Video Views
      label: Video Views
    - name: Tweet Likes
      label: Tweet Likes
    - name: Retweets
      label: Retweets
    - name: Workspace Watches
      label: Workspace Watches
    - name: Collection Watch
      label: Collection Watch
    - name: Collection Fork
      label: Collection Fork
  discussion: ''
  yaml: ''
- name: Improving Team Productivity
  version: '2021-11-24'
  description: Team productivity is the desire of any enterprise organization, and
    APIs provide a new way to find team productivity, but also quantify and make it
    something that is repeatable over time. APIs provide a modular and incremental
    way to iterate and move forward APIs behind applications and integrations, with
    the highest level of quality and perpetual forward motion possible.
  collection_id: 12959542-b9658606-ef38-4c0a-88c2-3552c2c82534
  image: images/blueprints/improving-team-productivity.png
  conclusion: Text
  tags:
  - Teams
  - Productivity
  roles:
  - Architect
  - Backend
  - Operations
  - Engineering
  - Frontend
  - Mobile
  - Product  
  state: Ready for Use
  type: Process
  maturity: Optimized
  level: 310
  areas:
  - label: Landscape
    description: 'If you want teams to be productive you need them to operate within
      a known landscape. Very few teams will do well in uncharted and unfamiliar territory.
      Having a map of your team landscape, the APIs they are building, and the workspaces
      and operations around them are required to achieve any level of desired productivity.  Mapping
      the team, workspace, and API landscape is the first thing you should be focusing
      on if you are striving to achieve greater productivity across teams, as you
      will learn a great deal about how things work and do not work in the process,
      and push your awareness and capacity trying to see, map, and understand what
      is happening at scale across these three areas. '
    image: images/lifecycle-arrow-define.png
    elements:
    - name: Team
      label: Team
    - name: Workspace
      label: Workspace
    - name: APIs
      label: APIs
  - label: Lifecycle
    description: As the landscape is coming into focus you will need to also begin
      developing a way of seeing and talking about the API lifecycle if you are looking
      to get a handle on productivity. The API and software development lifecycle
      are how teams, infrastructure, applications, integrations, and all of our operations
      move forward (or not). Understanding the current state of the API lifecycle
      across an organization, as well as establishing a vocabulary for describing
      and talking about, then moving towards a common set of services and tooling
      for realizing the API lifecycle is required to support teams in releasing often,
      and ensuring their releases are of the highest quality and meet with the expectations
      of consumers and other stakeholders.  A known API lifecycle is required before
      teams can start developing the muscle memory required to increase productivity,
      and keep an organization collectively in forwarding motion towards a common
      objective.
    image: images/lifecycle-arrow-define.png
    elements:
    - name: Discovery
      label: Discovery
    - name: Define
      label: Define
    - name: Design
      label: Design
    - name: Develop
      label: Develop
    - name: Deploy
      label: Deploy
    - name: Observe
      label: Observe
  - label: Design-First
    description: Opting to design APIs before actually beginning to write any code
      has emerged as the preferred way for teams to increase their performance when
      it comes to new APIs, but also each iteration of existing APIs. A design-first
      approach using OpenAPI as the central contract allows teams to design, mock,
      and document an API, then collaborate, communicate, and iterate upon that design
      until they have come to an agreement between produce and consumer regarding
      what it should do. Once an API behaves as intended as a mocked instance, tests
      can be established that ensure that functionality can be verified in development,
      staging, and production instances. Investing in the design of an API over diving
      in and writing code, taking a much more collaborative team approach to delivering
      APIs over an individualistic approach to just one person rolling up their sleeves
      and writing code. Demonstrating that the value in design-first isn't just the
      contract vs. code, but more about people working together to find the right
      solution, over a single person interpreting what is needed and codifying their
      view of things into operations.
    image: images/lifecycle-arrow-define.png
    elements:
    - name: OpenAPI
      label: OpenAPI
    - name: Mock Server
      label: Mock Server
    - name: Documentation
      label: Documentation
    - name: Testing
      label: Testing
  - label: Collaboration
    description: As demonstrated in the design-first portion of this blueprint, collaboration
      is essential for achieving team productivity across a known API lifecycle. Teams
      need to be able to rely on asynchronous ways to stay in tune with what is happening,
      engage in conversations about artifacts and other elements operations, and even
      focus on specific technical details of how APIs work. All of the moving parts
      of our API operations need to be accessible in a collaborative way, with work
      occurring in private, team, partner, or even sometimes public workspaces, and
      as a stakeholder, I need to be able to watch what is happening, fork and reuse
      or contribute to what is happening and be notified when anything changes that
      concern me. Moving from individual modes of development to collaborative approaches
      is an essential part of the API journey, and is necessary to increase the productivity
      of teams when it comes to moving the API ship forward.
    image: images/lifecycle-arrow-define.png
    elements:
    - name: Watch
      label: Watch
    - name: Comments
      label: Comments
    - name: Notifications
      label: Notifications
    - name: Sharing
      label: Sharing
    - name: Forks
      label: Forks
  discussion: ''
  yaml: ''
- name: Prototype a New API Using a Postman Collection
  version: '2021-09-11'
  description: Bringing a new API to life in a design-first way using a Postman collection
    to prototype the API, then an OpenAPI contract to help guide the API throughout
    the rest of its lifecycle--establishing a working design of an API before you
    define the contract for how it will work.
  image: images/blueprints/prototyping-a-new-api-using-a-postman-collection.jpeg
  tags:
  - Collections
  - New
  roles:
  - Advocate
  - Architect
  - Backend
  - Operations
  - Engineering
  - Frontend
  - Mobile
  - Product
  - Support
  - Writer  
  state: Ready for Use
  type: New
  maturity: Optimized
  level: 280
  areas:
  - label: Define
    description: The most important first step of any API lifecycle is to make sure
      the operations around an API are properly defined, laying the foundation for
      being able to effectively design and bring an API to life, while also establishing
      a known place, or places to go to get all the information you need regarding
      each individual API or groups of APIs. A little planning and organization at
      this early step of the API journey can go a long way towards ensuring the overall
      health and velocity of an API, and the applications and integrations that will
      depend on each internal, partner, or public API being delivered.
    image: images/lifecycle-arrow-define.png
    elements:
    - name: Team Workspace
      label: Team Workspace
      context: 1
    - name: Team Members
      label: Team Members
      context: 1
  - label: Design
    image: images/lifecycle-arrow-design.png
    description: Having a formal process and approach to designing an API helps establish
      consistency and the precision of APIs in production, ensuring that APIs are
      developed using common patterns across an industry, and within an organization,
      establishing known practices for shaping the surface area and behaviors of APIs
      that applications are depending upon. But instead of using OpenAPI as the catalyst
      for the API design process, a Postman collection is used to prototype the API,
      and then you can generate the OpenAPI from the collection when you are ready
      to move to production or at least a more stable portion of the API design phase.
    elements:
    - name: Prototype Collection
      label: Prototype Collection
    - name: OpenAPI
      label: OpenAPI
  - label: Mock
    image: images/lifecycle-arrow-mock.png
    description: Mocking how an API works and behaves provides an effective way for
      teams to collaborate, communicate, and iterate as part of the design of an API,
      but it also is something that can be used as part of testing, or just providing
      a sandbox environment for API consumers to learn before they actually begin
      working with any API in production. Effectively mocking an API takes a little
      time to set up and configure properly, but once available it will help reduce
      friction across the entire API lifecycle, helping teams more effectively communicate
      around an API throughout its journey.
    elements:
    - name: Mock Server
      label: Mock Server
      context: 1
    - name: Examples
      label: Examples
      context: 1
  - label: Document
    image: images/lifecycle-arrow-document.png
    description: Having complete, accurate, and easy-to-follow documentation is essential
      for all APIs and is something that alleviates the number one pain point for
      API consumers when it comes to onboarding with any API, expanding the number
      of API paths an application puts to work. Modern approaches to producing API
      documentation have moved beyond a single static version of documentation simply
      published to a portal, as well as there being potentially multiple forms of
      documentation for any single API. Helping API producers onboard consumers easier,
      reducing the cognitive load when understanding what an API does, and properly
      defining specific business use cases of an API being put to work in an application
      or as part of an integration.
    elements:
    - name: Reference Documentation
      label: Reference Documentation
      context: 1
  - label: Deploy
    image: images/lifecycle-arrow-deploy.png
    description: Establishing a well-defined process to deploy an API helps teams
      bring new APIs to life, as well as assists them in more efficiently delivering
      each future iteration of an API in a consistent and repeatable way. Ensuring
      APIs are deployed using known development, staging, production, and other agreed-upon
      states that actively apply other elements like documentation, testing, while
      natively contributing to observability. API deployment practices will likely
      have been well established as part of an organizations traditional software
      development lifecycle but is something that should be open to defining, standardizing,
      and making more repeatable and observable as part of the API lifecycle. The
      API deployment portion of the API lifecycle will be the most difficult for teams
      to properly define, articulate, and standardize across teams, but it will continue
      to be one of the most critical areas of the API lifecycle to do this for, otherwise,
      it will be guaranteed to be a repeated source of friction across API operations.
    elements:
    - name: CI/CD Pipeline
      label: CI/CD Pipeline
      context: 1
    - name: Gateway
      label: Gateway
      context: 1
  - label: Manage
    image: images/lifecycle-arrow-manage.png
    description: APIs should always be managed using a set of a common, well-defined
      set of policies that define and govern how APIs are accessed via all states
      of the API lifecycle, ensuring that every API has appropriate authentication,
      rate limits, logging, and other essential requirements of managing APIs at scale,
      helping strike a balance between making APIs accessible and the privacy and
      security concerns that exist. As API gateways and management solutions have
      been commoditized, many of the essential elements like documentation and testing
      have expanded into their own areas of the API lifecycle, leaving us with a core
      set of elements that can be applied by teams to help manage how APIs are put
      to work in applications and as part of system to system integrations.
    elements:
    - name: Onboarding
      label: Onboarding
      context: 1
    - name: Usage Plan
      label: Usage Plan
      context: 1
    - name: Key
      label: Key
      context: 1
  - label: Testing
    image: images/lifecycle-arrow-test.png
    description: A test-driven API lifecycle ensures that each API delivers the intended
      outcomes it was developed for in the first place, providing manual as well as
      automated ways to ensure an API hasn't changed unexpectedly and is as performant
      as required, helping establish a high quality of service consistently across
      all APIs. API testing should not be an afterthought and should be a default
      aspect of the API lifecycle for any API being put into production. API testing
      takes a solid investment in establishing proper testing practices across teams,
      but once you do the work to establish a baseline of testing, properly train
      teams on the process and tooling involved, the investment will pay off down
      the road.
    elements:
    - name: Contract Testing
      label: Contract Testing
      context: 1
    - name: Performance Testing
      label: Performance Testing
      context: 1
  - label: Secure
    image: images/lifecycle-arrow-test.png
    description: Security must be its own area of the API lifecycle, but it is something
      that should span testing, authentication, and potentially other areas of the
      API lifecycle. Over the last five years, the world of API security has expanded,
      while also moving further left in the API lifecycle as part of operations shift
      in how APIs are delivered. There are a number of elements present when it comes
      to security, but depending on the overall maturity of API operations the available
      resources and prioritization available to adequately realize these elements
      vary.
    elements:
    - name: Authentication
      label: Authentication
      context: 1
    - name: Security Testing
      label: Security Testing
      context: 1
  - label: Monitor
    image: images/lifecycle-arrow-monitor.png
    description: Monitors can be used to execute any Postman collection applied to
      any environment. Due to the versatility of what a Postman collection can define,
      collections turn monitors into powerful API automation and orchestration tool.
      Beginning with the ability to schedule contract, performance, and other types
      of tests, but then also allowing for automating specific workflows across many
      different APIs. Since collections can be used to define anything that can be
      defined via an API, monitors can be used to schedule the running of each capability
      from multiple cloud regions, applying many different environmental variables.
      Making monitors an essential, versatile, and executable part of defining how
      the API lifecycle works.
    elements:
    - name: Contract Testing Monitor
      label: Contract Testing Monitor
      context: 1
    - name: Performance Testing Monitor
      label: Performance Testing Monitor
      context: 1
    - name: Security Testing Monitor
      label: Security Testing Monitor
      context: 1
  - label: Discovery
    image: images/lifecycle-arrow-discover.png
    description: The ability to discover APIs at all states of the API lifecycle is
      essential for reducing redundancy across operations, helping teams find existing
      APIs before they develop new ones, properly matching API consumers with the
      right APIs, while supporting documentation, relevant workflows, and the feedback
      loops that exist as part of the operation of APIs internally within the enterprise,
      or externally with 3rd party developers. API discovery does not live at the
      beginning or the end of the API lifecycle, but should be considered across all
      areas of the API lifecycle, ensuring that APIs, as well as the operations around
      them, are as discoverable as possible, but well informed when it comes to privacy,
      security, and terms of service.
    elements:
    - name: Search
      label: Search
      context: 1
    - name: Private Network
      label: Private Network
      context: 1
    - name: Public Network
      label: Public Network
      context: 1
  discussion: https://github.com/postman-open-technologies/lifecycle/discussions/16
  yaml: https://github.com/postman-open-technologies/lifecycle/blob/main/_blueprints/prototype-a-new-api-using-collection.md
  collection_id: 12959542-770e02fc-b265-4614-ab1f-8f07de5f8d2a
- name: Public Teams, Workspaces, and APIs
  version: '2021-11-24'
  description: Documenting the members of a team behind APIs, and making their workspaces,
    APIs, collections, and other work publicly available is a potential way to bring
    more attention to the projects, and other work going on. Providing a more public
    approach to the API lifecycle that works to bring more attention to APIs, and
    increase the number of consumers who are putting it to work.
  collection_id: 12959542-828c1079-0895-469f-8c7a-0820e245ccf6
  image: images/blueprints/public-teams-workspaces-and-apis.jpeg
  tags:
  - Team
  - APIs
  - Collections
  - Workspaces
  - Public
  roles:
  - Advocate
  - Engineering
  - Product
  - Support
  - Writer  
  state: Work in Progress
  type: Public
  maturity: Optimized
  level: 250
  areas:
  - label: Team Profile
    description: Team profiles provide a great way to showcase the work a team is
      doing. A robust, informative, and visually attractive team profile page makes
      for optimal discovery via platform search, but also on the open web via search
      engines, and grabs the viewer as soon as they land on the page. Team profile
      pages provide the mechanisms to describe a team, providing a logo but also allow
      for sharing of links to a website, Github, and Twitter, as well as showcasing
      the workspaces, APIs, and collections a team has published. Having an up to
      date team profile page that reflects what a team is up to provides an opportunity
      to showcase the hard work of a team, but then also make it more discoverable
      and accessible to consumers who might find the resources and capabilities being
      made available useful as part of their applications and integrations.
    image: images/lifecycle-arrow-define.png
    elements:
    - name: Team Name
      label: Team Name
    - name: Team Favicon
      label: Team Favicon
    - name: Team Logo
      label: Team Logo
    - name: Team Cover Photo
      label: Team Cover Photo
    - name: Team Public URL
      label: Team Public URL
    - name: Team About
      label: Team Public
    - name: Team Website
      label: Team Website
    - name: Team Twitter
      label: Team Twitter
    - name: Team Github
      label: Team Github
  - label: Team Member Profile
    description: Profiling team members is as important as profiling the team, and
      there are many of the same mechanisms for individual team members to highlight
      their contributions. Team member profile pages provide the mechanisms to describe
      a team, providing a logo, but also allow for sharing of links to a website,
      Github, and Twitter, as well as showcasing the workspaces, APIs, and collections
      an individual team member has published. An individual team member profile page
      acts as a reflection of the work each person has contributed and provides a
      hands-on resume of what each person has been working on and has made available
      for others to learn from and use. Making our project portfolios and resumes
      much more hands-on, interactive, and demonstrating what we know, but done in
      a way that invites others to learn from our work.
    image: images/lifecycle-arrow-define.png
    elements:
    - name: Team Member Name
      label: Team Member Name
    - name: Team Member Username
      label: Team Member Username
    - name: Team Member Photo
      label: Team Member Photo
    - name: Team Member Cover Photo
      label: Team Member Cover Photo
    - name: Team Member About
      label: Team Member Public
    - name: Team Member Website
      label: Team Member Website
    - name: Team Member Twitter
      label: Team Member Twitter
    - name: Team Member Github
      label: Team Member Github
  - label: Public Profile
    description: 'Team and individual profiles offer a number of ways to showcase
      the team as well as individuals, but really it is the overall presentation of
      a profile that will have the biggest impact. The overall state of workspaces
      published, and the appearance and completeness of APIs and collections within
      them are what matters the most. Public profiles provide a simple, self-service,
      and an ongoing way for teams to manage their public presence within the API
      space, acting as the landing page for more than 18M developers within the Postman
      API network, but also on the open web. Public profiles provide a new way to
      emphasize individuals as well as teams as part of the API economy, going beyond
      the classic developer portal which does not reflect the human side of operations
      at all, and making sure we see the people behind APIs, but also the people who
      are consuming APIs. '
    image: images/lifecycle-arrow-define.png
    elements:
    - name: Public Profile Appearance
      label: Public Profile Appearance
    - name: Public Profile Completeness
      label: Public Profile Completeness
    - name: Public Profile Overview
      label: Public Profile Overview
    - name: Public Profile Collections
      label: Public Profile Collections
    - name: Public Profile APIs
      label: Public Profile APIs
    - name: Public Profile Workspaces
      label: Public Profile Workspaces
    - name: Public Profile Team Members
      label: Public Profile Members
  discussion: ''
  yaml: ''
- name: Leveraging Public Workspaces
  version: '2021-11-24'
  description: Make API workspaces public, provide the ability to engage with 3rd
    party consumers in the entire API lifecycle, making APIs, mock servers, documentation,
    testing, monitoring, and automation accessible to everyone, making APIs discoverable
    to public consumers, and increasing the possibilities for engagement through watching,
    forking, and feedback loops.
  collection_id: 12959542-097e36af-7141-4a82-abaa-cdd1dad32ff5
  image: images/blueprints/leveraging-public-workspaces.jpeg
  conclusion: Text
  tags:
  - Workspaces
  roles:
  - Advocate
  - Engineering
  - Product
  - Support
  - Writer  
  state: Work in Progress
  type: Public
  maturity: Optimized
  level: 280
  areas:
  - label: Contents
    description: Public workspaces provide an unprecedented opportunity to turn how
      you do APIs into an exhibition that others can learn from, and engage with.
      Public workspaces represent the next evolution in how we engage with consumers,
      evolving the classic API portal and Git repository into something that better
      reflects the API lifecycle. Public workspaces open up more engagement opportunities
      beyond just documentation, making the artifacts behind our API documentation,
      mocks, tests, and code generation something that is watchable and forkable,
      and able to be engaged with via comments. There is no limit to what public workspaces
      can contain, and as Github has done for open-source, public workspaces will
      do for APIs, making the API economy much more visible, accessible, and something
      you can put to work as part of your operations.
    image: images/lifecycle-arrow-define.png
    elements:
    - name: Collection
      label: Collection
    - name: APIs
      label: APIs
    - name: Environment
      label: Environment
    - name: Monitor
      label: Monitor
  - label: Engagement
    description: Public workspaces are taking engagement between API producers and
      consumers by providing some of the common elements of social networks as a native
      part of the API lifecycle. Building on the momentum that watches and forks have
      given Repository used in service of open-source software, OpenAPI, GraphQL,
      and SOAP APIs can now be watched, and the collections used for documentation,
      mock servers, testing, automation, and many other purposes can now also be watched
      but also forked. Both APIs and collections can also have a general comment,
      but more importantly inline comments on specific parameters, schema, scripts,
      and other moving parts of an API request. Public workspace makes the API lifecycle
      much more collaborative and open for discussion, reuse, and demonstration, shifting
      how you contribute as part of the API economy.
    image: images/lifecycle-arrow-define.png
    elements:
    - name: Contributors
      label: Contributors
    - name: Comments
      label: Comments
    - name: Watch
      label: Watch
    - name: Forks
      label: Forks
  discussion: ''
  yaml: ''
- name: Making Quality a Ubiquitous Part of Operations
  version: '2021-11-24'
  description: Assuring quality across teams when it comes to the delivery, operation,
    and evolution of APIs is top of mind for any enterprise organization. Realizing
    quality across many different teams and the APIs they develop takes a significant
    amount of planning and execution to ensure that there are contract, integration,
    performance, security, and other types of tests in place across 100% of APIs in
    operation.
  collection_id: 12959542-2e7c91e3-5c19-4ca2-bcc4-7a75d74e64b4
  image: images/blueprints/making-quality-a-ubiquitous-part-of-operations.jpeg
  tags:
  - Testing
  - Quality
  roles:
  - Advocate
  - Architect
  - Backend
  - CIO
  - CISO
  - CTO
  - Operations
  - Engineering
  - Frontend
  - Mobile
  - Product
  - Security  
  state: Work in Progress
  type: Quality
  maturity: Foundational
  level: 230
  areas:
  - label: Contracts
    description: API quality begins with every API possessing a complete and up-to-date
      machine-readable contract, and tests in place that verify that the contract
      for each API is being met. The JSON Schema present in our OpenAPI contracts
      can be used to automate the generation of tests for each contract, but also
      the automation of it on a schedule via monitors, and as part of the build process
      using CI/CD pipelines. The automation of contract testing provides us with 100%
      test coverage ensuring that we are meeting our business obligations to our internal,
      partner, and 3rd party consumers. Through the storing, aggregation, and analysis
      of results across this contract testing we are able to understand at scale whether
      or not we are living up to our promises when we set these APIs in motion, automating
      not just the technology of APIs, the business of what they enable.
    image: images/lifecycle-arrow-define.png
    elements:
    - name: Testing
      label: Testing
    - name: Monitor
      label: Monitor
    - name: Pipeline
      label: Pipeline
    - name: Results
      label: Results
  - label: Performance
    description: 'The automation of performance tests assures that we are meeting
      not just the availability of our APIs, but also the overall usability and quality
      of the service being provided. Performance tests can be easily defined for each
      API using collections, which can then be easily monitored on a schedule, and
      baked into the CI/CD pipeline. It is not recommended that you test the performance
      of every single API path and scenario, which renders performance testing looking
      more like a denial of service attack than it does quality assurance, but the
      selection of a few key API paths makes a lot of sense. Performance tests can
      be automated, and like other types of testing, the results can be stored and
      aggregated to understand performance over time, but also across all APIs for
      a team, domain, or organization. '
    image: images/lifecycle-arrow-define.png
    elements:
    - name: Testing
      label: Testing
    - name: Monitor
      label: Monitor
    - name: Pipeline
      label: Pipeline
    - name: Results
      label: Results
  - label: Security
    description: Security tests can be defined as individual collections, but then
      also scheduled for running via monitors, and baked into the CI/CD pipeline to
      make sure no APIs with common vulnerabilities make it through to production.
      Security testing adds another stack to the existing contract, integration, performance,
      and other types of testing that have become ubiquitous across enterprise organizations,
      shifting API security left in the development process by equipping API developers
      with OWASP top 10, and other types of proven tests and scans created centrally
      by security professionals. As with other tests, the results of API security
      testing can be aggregated, reported upon, and evaluated as a whole when looking
      at security for teams, domains, and entire enterprise organizations.
    image: images/lifecycle-arrow-define.png
    elements:
    - name: Testing
      label: Testing
    - name: Monitor
      label: Monitor
    - name: Pipeline
      label: Pipeline
    - name: Results
      label: Results
  - label: Governance
    description: API governance is the latest layer of testing to be added to the
      existing contract, performance, security, and other types of tests being applied
      and automated as part of the API lifecycle. Rather than using collections to
      test the instance of an API, ensuring it is living up to its contract, meeting
      SLA, and is secured, API governance collections are testing the surface area
      of the API, looking for standards and other common patterns required as part
      of a wider governance strategy. When operating via an API platform, these collections
      can also be used to test for the presence of documentation, contract, performance,
      and security testing, moving testing beyond just API design governance, and
      making it more about full API lifecycle governance. Allowing governance to be
      manually run by developers, but also automated on a schedule using monitors,
      and baked into the CI/CD process to enforce governance at build time. Completing
      our testing automation stack to ensure it is as robust and comprehensive regarding
      each individual API, but also collectively how APIs are being designed, deployed,
      and operated in production.
    image: images/lifecycle-arrow-define.png
    elements:
    - name: Design
      label: Design
    - name: Documentation
      label: Documentation
    - name: Testing
      label: Testing
    - name: Security
      label: Security
    - name: Monitor
      label: Monitor
  - label: Observability
    description: The automation of contract, performance, security, and governance
      testing using Postman collection introduces the opportunity for more observability
      across all APIs by piping in the run results via monitors into our application
      performance monitoring (APM) solutions and using native API platform reporting.
      Test automation using collections + monitors opens up individual outputs for
      each dimension of testing for individual APIs but is done in a consistent and
      platform-driven way that will scale across all APIs. Helping make sure that
      observability is the default across all APIs, but also available for each dimension
      of testing that exists, providing us the awareness we need across our operations
      to understand the state of the complex enterprise systems we are working to
      move forward.
    image: images/lifecycle-arrow-define.png
    elements:
    - name: Reports
      label: Reports
    - name: APM
      label: APM
  discussion: ''
  yaml: ''
- name: Starting with a Reference Collection
  version: '2021-11-24'
  description: Every API needs to have a complete reference collection available for
    consumers. Providing an always up-to-date reference of every detail of an API,
    what it does, and how developers can put it to use. Ensuring there is a detailed
    record that can be used for the documentation but then also producing other types
    of onboarding, capability, workflow, and other types of collections that will
    be needed.
  collection_id: 12959542-eb322973-2bfc-41af-8735-bc0bc845a277
  image: images/blueprints/starting-with-a-reference-collection.jpeg
  conclusion: Text
  tags:
  - Collection
  - Documentation
  roles:
  - Advocate
  - Product
  - Support
  - Writer  
  state: Work in Progress
  type: Definitions
  maturity: Foundational
  level: 130
  areas:
  - label: Purpose
    description: The most common type of collection you see emerge from API producers
      is what is called a reference collection. An approach that reflects most OpenAPI
      powered documentation you come across, but is available in a more portable,
      shareable, and forkable format. Reference API collections provide a complete
      catalog of paths available as part of the operation of an API, providing the
      full menu of what is possible for consumers. Providing a central source of truth
      that can be used for documentation, but also used to produce other types of
      collections for onboarding, workflows, and other use cases. The purpose of a
      reference collection is to provide a single comprehensive look at an API, which
      can then be commented upon, watched, and forked by consumers, providing them
      with the complete reference of what is possible with an API.
    image: images/lifecycle-arrow-define.png
    elements:
    - name: Documentation
      label: Documentation
    - name: Reference
      label: Reference
    - name: Source
      label: Source
    - name: Engagement
      label: Engagement
  - label: Structure
    description: If you have ever generated a reference collection from an OpenAPI
      you know there are several ways in which you can dictate the structure of the
      collections. Collections are intended to be a more executable representation
      of an API, providing an accounting of all paths, parameters, and other technical
      details, but organized in a way that allows for actual use within a specific
      environment. Reference collections provide authentication details and organize
      requests by logical folders that speak to how consumers will be needing to learn
      about what an API does. Ensuring there are always examples for every request
      and response, allowing consumers to fork the reference collection, generate
      a mock server, and play with each individual API without having to actually
      make live calls to the API, helping make onboarding and exploration a more hands-on
      experience.
    image: images/lifecycle-arrow-define.png
    elements:
    - name: Authentication
      label: Authentication
    - name: Folders
      label: Folders
    - name: Request
      label: Request
    - name: Examples
      label: Examples
  - label: Environment
    description: Text
    image: images/lifecycle-arrow-define.png
    elements:
    - name: States
      label: States
    - name: Variables
      label: Variables
    - name: Authorization Variables
      label: Authorization Variables
  - label: Engagement
    description: Reference collections provide us with a tremendous opportunity for
      engagement between API producers and consumers. Moving beyond historic approaches
      to publishing static or even dynamic documentation to a developer portal, reference
      collections provide you with all the information you need, but in a much more
      collaborative and portable format. Reference collections can be quickly shared
      via URL, published to a website, blog, and other locations using a Run in Postman
      button. These collections can also be watched, forked, and have pull requests
      submitted, allowing API producers to potentially merge changes and updates made
      by consumers into the central set of API references. All of this is changing
      how we engage around our APIs, but also documentation, making it much more hands-on
      and accommodating to the distributed and fast-moving API world we all live in.
    image: images/lifecycle-arrow-define.png
    elements:
    - name: Collection URL
      label: Collection URL
    - name: Collection Button
      label: Collection Button
    - name: Collection Watch
      label: Collection Watch
    - name: Collection Fork
      label: Collection Fork
    - name: Collection Pull Request
      label: Collection Pull Request
    - name: Collection Merge
      label: Collection Merge
  discussion: ''
  yaml: ''
- name: API Regulation is Here
  version: '2021-11-24'
  description: The regulation of APIs in the banking, healthcare and other industries
    has emerged over the last decade, and other API-centered regulation like GDPR,
    CCPA, and other rules targeting technology platform has already begun shaping
    how we do business on the web and our ubiquitous mobile devices, making regulation
    a top priority for the enterprise in the next decade.
  collection_id: 12959542-574d9a8a-c687-43e7-a1ac-fc3dd928f5cc
  image: images/blueprints/api-regulation-is-here.jpeg
  conclusion: Text
  tags:
  - Regulation
  - Compliance
  roles:
  - Architect
  - CIO
  - CISO
  - CTO
  - Operations
  - Engineering
  - Security  
  state: Work in Progress
  type: Regulations
  maturity: Optimized
  level: 330
  areas:
  - label: Operations
    description: Depending on what industry, country, and state you operate in, your
      API operations are increasingly being shaped and defined by government regulation.
      Regulation can define many aspects of how we operate, but how we operate will
      also define how we respond to regulations, rules, and the ongoing need to be
      compliant. Our ability to discover our digital resources and capability via
      APIs will make our response to regulatory inquiries and the ongoing demands
      of regulators much easier to respond to. When API governance is already in place
      across operations it becomes much easier to steer the enterprise towards perpetual
      compliance, than it is if you are still just getting started governing the design,
      development, deployment, and operation of our API infrastructure. Ultimately,
      without observability already in place to possess the awareness of what is happening
      across teams and domains, regulatory compliance will continue to be daunting
      for organizations, making API discovery, governance, and observability all tightly
      coupled with the impact regulations have on our businesses.
    image: images/lifecycle-arrow-define.png
    elements:
    - name: Discovery
      label: Discovery
    - name: Governance
      label: Governance
    - name: Observability
      label: Observability
  - label: Compliance
    description: Regulatory compliance is not a one-time thing, and there are aspects
      of API operations that allow us to codify regulatory requirements into our operations
      using linting rules applied at design time, but also operationally in a variety
      of automated ways. This application of rules across all APIs allows for reporting
      on the state of compliance across teams, Augmenting existing quality and governance
      with a regulatory layer, that allows the enterprise to codify needs associated
      with compliance as rules that are defined and executed via collections that
      are automated on a schedule and within CI/CD pipelines. These rules can be aggregated
      and reported upon to understand the state of compliance across teams and domains,
      making regulation more visible and tangible as a regular part of our operations.
    image: images/lifecycle-arrow-define.png
    elements:
    - name: Rules
      label: Rules
    - name: Reports
      label: Reports
  discussion: ''
  yaml: ''
- name: Anatomy of Individual API Requests
  version: '2021-11-24'
  description: API requests are the fuel for the digital economy, reading and writing
    data, content, and media online across every business sector. HTTP API requests
    have become the common building block of web, mobile, and device applications,
    and understanding the technical details of individual API requests are essential
    to how you conduct business online today.
  collection_id: 12959542-71d1df64-1c33-4ddd-9d23-d69375ed67ca
  image: images/blueprints/anatomy-of-individual-api-requests.jpeg
  conclusion: Text
  tags:
  - Requests
  - Responses
  roles:
  - Backend
  - Data
  - Operations
  - Engineering
  - Frontend
  - Mobile
  - Product
  - Security
  - Writer  
  state: Work in Progress
  type: Base
  maturity: Foundational
  level: 105
  areas:
  - label: Request
    description: 'It can be very helpful to pause, step back, and think about the
      parts of each individual API request. We produce and consume so many API requests
      as part of our regular operations that we don''t always have the time to stop
      and think about the details of each request and why they matter. If we are simply
      consuming an API we don''t have as much control over what these details are,
      but if we are producing APIs it helps to put on our API consumer hat and think
      about why these parts and pieces matter. Postman collections provide us with
      useful ways for breaking down each request we are making, contemplating which
      methods we use, how we apply parameters, headers, and bodies, and then also
      secure these resources and capabilities with authentication. Good API producers
      are also API consumers, feeling the pain of design constraints, and working
      within the request vocabulary given, and spending regular time studying and
      thinking about the anatomy of API requests will make you more effective in your
      work. '
    image: images/lifecycle-arrow-define.png
    elements:
    - name: HTTP Methods
      label: HTTP Methods
    - name: URL
      label: URL
    - name: Query Parameters
      label: Query Parameters
    - name: Authentication
      label: Authentication
    - name: Request Headers
      label: Request Headers
    - name: Request Bodies
      label: Request Bodies
    - name: Request Settings
      label: Request Settings
  - label: Response
    description: The outcome of each API request is of course its response. Something
      that is completely shaped by the request, but then comes with its own set of
      controls for further defining what you'll see and experience. While the request
      will shape the body of the response, the overall experience can be further shaped
      by the network in which the API request is being made, and can be further rendered
      and visualized using the Postman visualizer. Headers, Cookies, and network details
      can play a significant role in understanding why an API request is behaving
      in unexpected ways, and can play a big part in testing, securing, and governing
      APIs. Depending on what your goals are in using an API, the meta details around
      each API response might be just as important as the API respond body itself.
      If we are unaware of these details, we may never fully understand why an API
      is behaving as it is, and may not have the control we need to achieve the outcomes
      we desire.
    image: images/lifecycle-arrow-define.png
    elements:
    - name: Response Body
      label: Response Body
    - name: Cookies
      label: Cookies
    - name: Response Headers
      label: Response Headers
    - name: Visualizer
      label: Visualizer
    - name: Response Network
      label: Response Network
    - name: Response Time
      label: Response Time
  discussion: ''
  yaml: ''
- name: Putting Security in the Hands of Developers with Collections
  version: '2021-11-24'
  description: The security for APIs means security behind the applications and integrations
    that depend on them, making API security a top priority for enterprise organizations
    today. Security is much more than encryption and requiring keys for APIs, and
    there are a number of proven approaches to making sure APIs are consistently secure
    no matter what team is producing or consuming them, using machine-readable collections.
  collection_id: 12959542-69d86a2d-ff0a-4cd9-8e2a-41294ec06841
  image: images/blueprints/putting-security-in-the-hands-of-developers-with-collections.jpeg
  conclusion: Text
  tags:
  - Security
  roles:
  - Backend
  - Operations
  - Engineering
  - Frontend
  - Mobile
  - Product
  - Security  
  state: Work in Progress
  type: Security
  maturity: Optimized
  level: 240    
  areas:
  - label: Folders
    description: Collection folders allow for not just the organization of API security
      requests, but also the execution of scripts that help set the stage for requests
      being made within a specific folder group, but then also do some housekeeping,
      aggregation, and other activities after a group of security requests have been
      made against APIs. When it comes to security testing, collection folders provide
      us with ways to logically group requests based upon the type of security test
      being applied, and in which order, but when it comes to the voodoo that often
      occurs as part of the manipulation of APIs behind web and mobile applications,
      these folders also allow us to get very creative in how we automate what we
      are going to be throwing at our APIs as part of security testing.
    image: images/lifecycle-arrow-define.png
    elements:
    - name: Pre-Request Scripts
      label: Pre-Request Scripts
    - name: Test Scripts
      label: Test Scripts
  - label: Request
    description: Each individual API request included as part of API security testing
      also has its own pre-request, but also post-request test script that adds an
      automation layer to API security testing. Each collection request can represent
      any possible API request being made via HTTP, making it a perfect vehicle for
      executing API security testing by leveraging the scripting layer present with
      each request for security-specific attacks. Collections can be used to develop
      very generic API testing using common threats as defined by OWASP top 10, or
      they can be used to craft very specialized and domain-specific security testing
      that can then be shared, forked and automated by API developers as part of operations.
      Opening up the opportunity for collections to be defined by security professionals,
      but then executed as part of operations by average developers, quality, operations,
      and other types of team roles.
    image: images/lifecycle-arrow-define.png
    elements:
    - name: Pre-Request Scripts
      label: Pre-Request Scripts
    - name: Test Scripts
      label: Test Scripts
  - label: Response
    description: The response and results of API security tests can be visualized
      using test results and runner views, but also rendered in more custom ways using
      the visualizer pane. Test results can also be published to another location
      via API, aggregating security results across many different APIs, allowing reporting
      by API, team, and domain. Responses for security tests provide us with a rich
      way to understand the security of our operations, focusing on a single API,
      or if tested and monitored properly, see API security at scale across operations.
    image: images/lifecycle-arrow-define.png
    elements:
    - name: Test Results
      label: Test Results
  - label: Automation
    description: Having API security collections defined as collections opens up two
      distinct ways that you can then automate API security. First, you can schedule
      security tests to run on a schedule from multiple cloud regions, helping evaluate
      security across APIs in an ongoing way. Next, you can also bake API security
      into the build process by running collections as part of CI/CD pipelines, adding
      security testing alongside contract, integration, performance, and other types
      of testing already occurring here. Security defined as collections allow us
      to make security much more modular and executable, and something that can be
      manually run by any developer, but also made a required part of moving APIs
      from design to production, ensuring that the same level of security is being
      applied across APIs, no matter which team is developing them.
    image: images/lifecycle-arrow-define.png
    elements:
    - name: Monitor
      label: Monitor
    - name: Pipeline
      label: Pipeline
  - label: Observability
    description: When API security is defined as collections it provides a standardized
      set of outputs that when run as monitors can be natively reported upon and piped
      into existing APM solutions. by tapping
      into the outputs provided by API security collections you can increase the observability
      for each individual API, but also across teams, domains, and potentially offer
      100% observability for all APIs used within an organization. Collections can
      map to any API, but then provide authorization, scripting, visualization, and
      integrations we can tap to make sure our API operations are more observable,
      providing us with the awareness we need to steer the enterprise ship in the
      direction we want to head.
    image: images/lifecycle-arrow-define.png
    elements:
    - name: Reports
      label: Reports
    - name: APM
      label: APM
  discussion: ''
  yaml: ''
- name: Always Investing in Standards
  version: '2021-11-24'
  description: There are numerous web, industry, and enterprise standards to be considered
    as we produce and consume APIs each day. Investing in standards for the design,
    authentication, and other moving parts of our API operations helps reduce friction
    throughout the API lifecycle, making our APIs as interoperable and intuitive as
    possible, saving time and money down the road.
  collection_id: 12959542-8480ef83-e4a7-4117-a20f-94c70b0bbd20
  image: images/blueprints/always-investing-in-standards.jpeg
  conclusion: Text
  tags:
  - Standards
  - Governance
  roles:
  - Advocate
  - Architect
  - CIO
  - CISO
  - CTO
  - Operations
  - Engineering
  - Product
  - Security  
  state: Work in Progress
  type: Standards
  maturity: Optimized
  level: 290
  areas:
  - label: Internet
    description: APIs are just the next evolution of the web, and there are a number
      of existing Internet standards that should be applied regularly as part of API
      operations. Authentication, headers, content-type, and many other moving parts
      of the API requests and responses we are using in our applications and integrations
      are just standards, and our teams should be given the time and space to explore,
      study, learn and apply existing Internet standards as part of their work. Once
      standards have been identified and applied, there are ways that they can be
      incorporated into existing training and governance efforts to help ensure all
      teams are properly applying the Internet standards as part of their regular
      work.
    image: images/lifecycle-arrow-define.png
    elements:
    - name: Internet Assigned Numbers Authority (IANA)
      label: Internet Assigned Numbers Authority (IANA)
    - name: Request for Comments (RFCs)
      label: Request for Comments (RFCs)
  - label: Industry
    description: Data, and other interoperability and communication standards have
      existed at the industry level since the birth of compute and the Internet, but
      more recently are being evolved to support modern approaches to delivering APIs
      behind web, mobile, device, and other types of applications. API standards for
      healthcare and financial sectors are already here, providing schema, OpenAPI,
      and other supporting guidance for API producers to use as part of their operations.
      PSD2 has primarily been a European effort but is being emulated in other markets
      around the world, and FHIR is primarily a US effort, similarly is beginning
      to be emulated and used in other places. Healthcare and finance are just the
      tip of the iceberg when it comes to the industry being touched by API standards
      today, and we'll see the sectors exponentially grow each year for the foreseeable
      future.
    image: images/lifecycle-arrow-define.png
    elements:
    - name: PSD2
      label: PSD2
    - name: Fast Healthcare Interoperability Resources (FHIR)
      label: Fast Healthcare Interoperability Resources (FHIR)
  - label: Organizational
    description: Every enterprise organization should have a set of standards they
      have adopted as part of API operations. There are plenty of redundant aspects
      of doing APIs that are easy to make consistent across APIs, things like pagination,
      sorting, filtering, usage of request bodies, HTTP methods, and error handling.
      It is important to identify what the common patterns are across the enterprise,
      then formalize them as standards for how APIs are designed, developed, and operated,
      making sure to spend time educating and enabling teams when it comes to applying
      the standards as part of their work. This list is meant to just provide a starting
      point for thinking about common standards within the enterprise, and not act
      as a comprehensive list for all organizations.
    image: images/lifecycle-arrow-define.png
    elements:
    - name: Pagination
      label: Pagination
    - name: Headers
      label: Headers
  discussion: ''
  yaml: ''
- name: Having an API Strategy
  version: '2021-11-24'
  description: You just can't move forward an enterprise organization in a digital
    world without an API strategy. Establishing a formal, living, and evolving way
    of defining what your goals are with developing, operating, and evolving the API
    infrastructure behind the applications and integrations we depend on, and moving
    forward with a common strategy for how this all works across teams.
  collection_id: 12959542-4ac9fb65-87b8-4807-849c-d3a3b4a413e6
  image: images/blueprints/having-an-api-strategy.jpeg
  tags:
  - Strategy
  roles:
  - Advocate
  - Architect
  - CIO
  - CISO
  - CTO
  - Operations
  - Engineering
  - Product  
  state: Work in Progress
  type: Strategy
  maturity: Optimized
  level: 240
  areas:
  - label: Organization
    description: A formal API strategy begins with helping better define and organize
      some of the more business and human aspects of operating an enterprise organization.
      Defining logical business domains often gets introduced into API operations
      through the adoption of domain-driven design work in service of API governance.
      There are plenty of benefits in taking this formal approach, but there are some
      simple areas you can focus on when it comes to establishing more of a strategy
      for how you do APIs, without all the formality. Carving up your enterprise in
      logical domains, groups, and teams that fall along existing operational bounded
      contexts helps leadership get more of a lay of the land, from which a strategy
      can be developed for what might come next when it comes to these boundaries
      defining and shaping API operations. Drawing the lines that make up the enterprise
      in ways that help make API operations more precise, discoverable, and repeatable
      is a good first place to begin with any API strategy.
    image: images/lifecycle-arrow-define.png
    elements:
    - name: Domains
      label: Domains
    - name: Groups
      label: Groups
    - name: Team
      label: Team
  - label: Governance
    description: The success of your API strategy will be defined by your ability
      to govern how things work. Establishing an organization-wide, platform-defined
      API strategy should consider how operations will be governed by establishing
      common workspaces for teams to develop and operate APIs, what are the consistent
      standards and patterns that need applying as part of the design of APIs, and
      how documentation, testing, and security will be applied across teams. Early
      on in your journey to establish an API strategy you can start simple, just by
      writing a short narrative for how you'd like to approach governance in each
      of these areas, but as you progress you can get more detailed in how you provide
      guidance and guardrails in these areas and eventually establishing rules and
      tests that ensure teams are in alignment with the wider strategy.  However,
      we must not try to boil the ocean, and just starting simple can help bring the
      change needed in the areas that matter most, providing teams with a simple narrative
      around what API governance means.
    image: images/lifecycle-arrow-define.png
    elements:
    - name: Workspace
      label: Workspace
    - name: Design
      label: Design
    - name: Documentation
      label: Documentation
    - name: Management
      label: Management
    - name: Testing
      label: Testing
    - name: Security
      label: Security
  - label: Standards
    description: Establishing standards is a big part of developing an enterprise
      API strategy. Identifying, understanding, and then adding Internet and industry
      standards to an organization's API strategy will be a regular part of this living
      document. Most API strategies begin as a simple fork of other API strategies
      that have been shared by other enterprise organizations that are brave enough
      to share, but then they can evolve and adapt to meet an organization's specific
      needs within their culture and business sector. 50% of an organization's API
      strategy will be defined and shaped by the Internet and industry standards,
      with another 25% shaped by the services and tools you adopt, but that final
      25% should be all about the art of your enterprise and the domains you are experts
      in. You should always work to make standards the bedrock of your API strategy,
      as this will help you reduce friction for your consumers, and optimize your
      organization's ability to recruit, hire, and bring new team members up to speed.
    image: images/lifecycle-arrow-define.png
    elements:
    - name: Internet Standards
      label: Internet Standards
    - name: Industry Standards
      label: Industry Standards
    - name: Organizational Standards
      label: Organizational Standards
  discussion: ''
  yaml: ''
- name: Investing in Test Automation
  version: '2021-09-11'
  description: Test automation is essential for delivering reliable and consistent
    APIs at scale across the enterprise. This is a blueprint for walking through the
    base of how test automation can work as part of a well-defined API lifecycle,
    helping teams standardize how they approach testing APIs.
  collection_id: 12959542-426baa5c-500f-4ba0-b270-522e20c75808
  image: images/blueprints/investing-in-test-automation.jpeg
  tags:
  - Automation
  - Testing
  roles:
  - Advocate
  - Architect
  - Backend
  - Operations
  - Engineering
  - Frontend
  - Mobile
  - Product
  - Support
  - Writer  
  state: Ready for Use
  type: Testing
  maturity: Optimized
  level: 225
  areas:
  - label: Define
    description: The most important first step of any API lifecycle is to make sure
      the operations around an API are properly defined, laying the foundation for
      being able to effectively design and bring an API to life, while also establishing
      a known place, or places to go to get all the information you need regarding
      each individual API or groups of APIs. A little planning and organization at
      this early step of the API journey can go a long way towards ensuring the overall
      health and velocity of an API, and the applications and integrations that will
      depend on each internal, partner, or public API being delivered.
    image: images/lifecycle-arrow-define.png
    elements:
    - name: Team Workspace
      label: Team Workspace
      context: 1
    - name: Team Members
      label: Team Members
      context: 1
    - name: Github Repository
      label: Github Repository
      context: 1
    - name: OpenAPI
      label: OpenAPI
      context: 1
  - label: Testing
    image: images/lifecycle-arrow-test.png
    description: A test-driven API lifecycle ensures that each API accomplishes the
      intended purpose it was developed for, providing manual and automated ways to
      ensure an API hasn't changed unexpectedly, is as performant as required, and
      meets the security expectations of everyone involved, helping establish a high
      quality of service consistently across all APIs.
    elements:
    - name: Contract Testing
      label: Contract Testing
  - label: Monitor
    image: images/lifecycle-arrow-monitor.png
    description: All tests applied to an API should be monitored on a logical schedule
      and from relevant geographic regions, monitoring that APIs aren't breaking their
      contract, falling below their agreed-upon service level agreement (SLA), or
      becoming a security risk, helping automate the quality of service across APIs
      in a way that allows teams to be as productive as possible.
    elements:
    - name: Monitor
      label: Monitor
    - name: Contract Testing Monitor
      label: Contract Testing Monitor
    - name: Contract Testing Results
      label: Contract Testing Results
  - label: Build
    image: images/lifecycle-arrow-deploy.png
    description: Tests can be automated using a CI/CD pipeline, allowing for tests
      to be executed every time a commit or pull request is made against a repo. Allowing
      tests to be run against any instance of an API, ensuring that any API being
      deployed has not broken its contract, and the API does what is expected.
    elements:
    - name: CI/CD Pipeline
      label: CI/CD Pipeline
      context: 1
    - name: Newman
      label: Newman
      context: 1
    - name: Development Environment
      label: Development Environment
    - name: Production Environment
      label: Production Environment
    - name: Contract Testing
      label: Contract Testing
    - name: Contract Testing Results
      label: Contract Testing Results
  - label: Observability
    image: images/lifecycle-arrow-observability.png
    description: Tapping into the outputs available across API operations to understand
      what is happening with individual APIs throughout their lifecycle, but also
      in aggregate for domains, teams, and other logical groups, helping make API
      operations more visible in real-time.
    elements:
    - name: Activity
      label: Activity
    - name: Reports
      label: Reports
    - name: Contract Testing Monitor Report
      label: Contract Testing Monitor Report
    - name: APM
      label: APM
  discussion: https://github.com/postman-open-technologies/lifecycle/discussions/33
  yaml: https://github.com/postman-open-technologies/lifecycle/blob/main/_blueprints/test-automation.md
- name: Fundamental API Testing
  version: '2021-11-24'
  description: These blueprints provide an overview of API testing, outlining the
    moving parts of a test collection, and how scripting provides the ability to test
    and automate quality for each API. Providing a very universal and flexible approach
    to API testing that can be used across teams to ensure that there is 100% test
    coverage present across API operations.
  collection_id: 12959542-6e04eef3-8fc7-4e13-b797-3d9374f8801f
  image: images/blueprints/fundamental-api-testing.jpeg
  tags:
  - Testing
  roles:
  - Advocate
  - Backend
  - Data
  - Operations
  - Engineering
  - Frontend
  - Mobile
  - Product
  - Security
  - Writer  
  state: Ready for Use
  type: Testing
  maturity: Foundational
  level: 170
  areas:
  - label: Folders
    description: Test collections can be organized by folder, allowing you to define
      as many API requests as you need, but then organize them logically by folder,
      based upon how they are applied. Allowing you to organize and determine the
      order in which tests are executed, but then also name and document your groups
      of tests in intuitive ways, so that other team members can use them. Collection
      folders allow you to organize your test requests, but they also come with their
      own ability to execute scripts.
    image: images/lifecycle-arrow-define.png
    elements:
    - name: Folder Pre-Request Scripts
      label: Folder Pre-Request Scripts
    - name: Folder Test Scripts
      label: 'Folder Test Scripts '
  - label: Request
    description: Test collections allow you to organize one or many different requests
      into a single shareable and executable format. Requests allow you to define
      the authentication, paths, parameters, headers, body, and other elements of
      each API you are looking to test. You can define as many requests as you like,
      put them in the order you wish them to run, and organize them by folder, giving
      you a powerful way to define many different types of tests, for many different
      types of APIs. Each request comes with two scripting elements that allow you
      to maximize how you test and automate the execution of your API tests, based
      upon the needs of each API.
    image: images/lifecycle-arrow-define.png
    elements:
    - name: Request Pre-Request Scripts
      label: Request Pre-Request Scripts
    - name: Request Test Scripts
      label: Request Test Scripts
  - label: Responses
    description: The requests within test collection each have a response panel where
      you can see the response bodies, headers, cookies, network, and other information
      for each API request. The response panel provides you with a wealth of detail
      regarding each API, but it provides one element that makes it much easier for
      API developers, testers, Operations, and other roles to easily understand the
      results of tests that are being defined and executed as collections.
    image: images/lifecycle-arrow-define.png
    elements:
    - name: Test Results
      label: Test Results
  - label: Automation
    description: Test collections provide a shareable and executable set of requests
      and accompanying test scripts that can be run by anyone who has the proper access
      to the collection and the API. Postman collections provide a universal format
      for automation that can be run within the Postman API platform, but also externally
      within CI/CD pipelines, and 3rd party services. Providing a human and machine-readable
      format for defining tests that are portable and able to be run by testers within
      workspaces, scheduled and execute across cloud Environment, and baked into the
      CI/CD process that is integrating and deploying the APIs we depend on.
    image: images/lifecycle-arrow-define.png
    elements:
    - name: Testing Runners
      label: 'Testing Runners '
    - name: Testing Monitors
      label: Testing Monitors
    - name: Testing Pipelines
      label: Testing Pipelines
  - label: Observability
    description: Test collections help contribute to the overall observability of
      API Operations by making providing outputs for APIs that can be used in reporting,
      dashboards, and other ways operations are made visible to teams. Depending on
      the types of tests being defined by collections, they allow for a new observability
      data point to be created that contributes to being able to see each individual
      API, its health, performance, and whether an API and the team behind are meeting
      their service level agreements. Bringing much-needed observability across API
      operations by providing teams with what they need to an individual do their
      part to bring higher levels of quality to the APIs they deliver.
    image: images/lifecycle-arrow-define.png
    elements:
    - name: Testing Reporting
      label: Testing Reporting
    - name: Testing APM Integration
      label: Testing APM Integration
  discussion: ''
  yaml: ''
- name: The Base of the API Lifecycle
  version: '2021-09-11'
  description: This blueprint illustrates what we consider to be the base of the API
    lifecycle, providing a starting point for additional lifecycle variations elsewhere
    on this site. Depending on your priorities and your entry point, you may need
    to expand or remove from this base lifecycle to match your desired situation.
  collection_id: 12959542-93680462-9da4-464e-9703-a064c31bd763
  image: images/blueprints/the-base-of-the-api-lifecycle.jpeg
  tags:
  - Lifecycle
  roles:
  - Advocate
  - Architect
  - Backend
  - CIO
  - CISO
  - CTO
  - Operations
  - Engineering
  - Frontend
  - Mobile
  - Product
  - Security
  - Writer  
  state: Ready for Use
  type: Base
  maturity: Foundational
  level: 190
  areas:
  - label: Define
    description: Making sure the operations around an API are properly defined, laying
      the foundation for being able to effectively design and bring an API to life,
      while also establishing a known place, or places to go to get all the information
      you need regarding each individual API or group of APIs.
    image: images/lifecycle-arrow-define.png
    elements:
    - name: Team Members
      label: Team Members
    - name: Team Workspace
      label: Team Workspace
    - name: Public Workspace
      label: Public Workspace
    - name: Github Repository
      label: Github Repository
  - label: Design
    image: images/lifecycle-arrow-design.png
    description: Establishing a formal process and approach to designing an API helps
      establish consistency of each API that ends up in production, ensuring that
      APIs are developed using common industry and organizational patterns while establishing
      known practices for shaping the surface area and behaviors of APIs.
    elements:
    - name: OpenAPI
      label: OpenAPI
    - name: Mock Server
      label: Mock Server
    - name: Comments
      label: Comments
  - label: Document
    image: images/lifecycle-arrow-document.png
    description: Having complete, accurate, and easy-to-follow documentation is essential
      for all APIs, alleviating the number one pain point for API consumers when it
      comes to onboarding with APIs, providing the human-readable technical details
      of what an API does, helping minimize the time to the first API call.
    elements:
    - name: Reference Documentation
      label: Reference Documentation
      context: 1
    - name: Examples
      label: Examples
      context: 1
  - label: Deploy
    image: images/lifecycle-arrow-deploy.png
    description: Providing a well-defined process to deploy an API into development,
      staging, and production Environment, helping teams efficiently deliver future
      iterations of an API in a consistent and repeatable way, ensuring that APIs
      are properly tested, secured, and governed as a native part of the deployment
      process.
    elements:
    - name: CI/CD Pipeline
      label: CI/CD Pipeline
      context: 1
    - name: Gateway
      label: Gateway
      context: 1
    - name: Usage Plan
      label: Usage Plan
      context: 1
  - label: Testing
    image: images/lifecycle-arrow-test.png
    description: A test-driven API lifecycle ensures that each API delivers the intended
      outcomes it was developed for in the first place, providing manual as well as
      automated ways to ensure an API hasn't changed unexpectedly and is as performant
      as required, helping establish a high quality of service consistently across
      all APIs.
    elements:
    - name: Contract Testing
      label: Contract Testing
      context: 1
    - name: Performance Testing
      label: Performance Testing
      context: 1
  - label: Secure
    image: images/lifecycle-arrow-test.png
    description: Ensuring that there is a consistent approach to identity and access
      management for each API, but also the proper security testing in place to make
      sure that all APIs are being secured in a consistent way no matter which team
      developed them, or whether they will be used for private, partner, or public
      use in applications.
    elements:
    - name: Authentication
      label: Authentication
      context: 1
    - name: Security Testing
      label: Security Testing
      context: 1
  - label: Monitor
    image: images/lifecycle-arrow-monitor.png
    description: Making sure that all APIs are fully monitored by scheduling contract,
      performance, security, and other tests from multiple cloud regions, but also
      being able to monitor the activity, changelog, and state of an API using notifications,
      helping keep teams and consumers informed regarding the state of the APIs they
      depend on.
    elements:
    - name: Contract Testing Monitor
      label: Contract Testing Monitor
      context: 1
    - name: Performance Testing Monitor
      label: Performance Testing Monitor
      context: 1
    - name: Security Testing Monitor
      label: Security Testing Monitor
      context: 1
    - name: Activity
      label: Activity
    - name: Change Log
      label: Change Log
    - name: Notifications
      label: Notifications
  - label: Discovery
    image: images/lifecycle-arrow-discover.png
    description: Enabling discovery across operations, helping teams find existing
      APIs before they develop new ones, properly matching API consumers with the
      right APIs, while supporting documentation, workflows, and the feedback loops
      that exist as part of the operation of internal, partner, and public APIs supporting
      applications and integrations.
    elements:
    - name: Search
      label: Search
      context: 1
    - name: Private Network
      label: Private Network
      context: 1
    - name: Public Network
      label: Public Network
      context: 1
  discussion: https://github.com/postman-open-technologies/lifecycle/discussions/27
  yaml: https://github.com/postman-open-technologies/lifecycle/blob/main/_blueprints/base.md
- name: Versioning Governance
  version: '2021-12-06'
  description: Kicking off API governance efforts by starting with versioning across
    APIs. Adopting a specific pattern to version all APIs, then work to govern that
    it is applied during the design, development, and delivery of APIs. Starting simple
    with API governance, establish a pattern and process, then expand API governance
    efforts once you have your legs under you.
  image: images/blueprints/versioning-governance.jpeg  
  conclusion: Text
  tags:
  - Versioning
  - Governance
  roles:
  - Architect
  - Engineering
  - Product  
  state: Ready for Use
  type: Base
  maturity: Foundational
  level: 240
  areas:
  - label: Definitions
    description: You cannot govern APIs that do not have a definition, and OpenAPI
      is the preferred specification for defining the surface area of APIs. Any API
      being developed must have an OpenAPI available, either hand-crafted as part
      of a design-first approach, or generated from a gateway or code-first approach.
      With this definition, you will then be able to begin applying a consistent versioning
      approach, and then begin assessing whether or not versioning is being consistently
      applied across teams.
    image: images/lifecycle-arrow-define.png
    elements:
    - name: OpenAPI
      label: OpenAPI
  - label: Versioning
    description: Before you can govern the versioning of each API you have to have
      a formal approach for how you will apply versioning across APIs. Picking one
      of the most common approaches to version each API, working out the implementation
      details of the chosen pattern, and providing guidance for teams around why versioning
      is important, and how to implement it. There are two primary approaches to versioning
      that are adopted across leading APIs, making it an easy choice to find the patterns
      you need.
    image: images/lifecycle-arrow-define.png
    elements:
    - name: Semantic Versioning
      label: Semantic Versioning
    - name: Date-Based Versioning
      label: Date-Based Versioning
  - label: Linting
    description: With an OpenAPI for each API, and a versioning pattern adopted, you
      can lint for this pattern across each API using a rules-based approach to governance.
      Leveraging the open-source tool Spectral to define a machine-readable rule that
      matches the versioning pattern adopted, and then ensuring the OpenAPI for each
      API possesses the pattern during design, development, and build time. Codifying
      governance rules, and then automating how they are applied to ensure that versioning
      is consistently applied across operations.
    image: images/lifecycle-arrow-define.png
    elements:
    - name: Versioning Governance Rules
      label: Versioning Governance Rules
  - label: Automation
    description: With API versioning governance in place, it can now be automated
      as part of operations, ensuring the coverage of governance across teams. Providing
      the ability to lint for version governance rules, but eventually many other
      rules at the various stages of the lifecycle. Defining API governance in a centralized
      way, but then equipping development teams to apply it as part of their regular
      workflows, automating how governance is implemented, and pushing for 100% coverage
      of API versioning governance across operations.
    image: images/lifecycle-arrow-define.png
    elements:
    - name: Design Time Governance
      label: Design Time Governance
    - name: Collection Governance
      label: Collection Governance
    - name: CLI Governance
      label: CLI Governance
    - name: IDE Governance
      label: IDE Governance
    - name: Pipeline Governance
      label: Pipeline Governance
  discussion: ''
  yaml: ''
  collection_id: 12959542-21947610-4663-40d0-8a3a-0ef72f805645
- name: More Organizational Visibility
  version: '2021-11-24'
  description: Very few enterprise organizations have visibility into the digital
    infrastructure that has emerged over the last 25 years of operating on the web.
    APIs have become the fundamental building block behind the web, mobile, cloud,
    device, and other technological evolution of the last couple of decades, and the
    enterprise organizations who have visibility into what APIs exist are the ones
    who are able to define what comes next.
  collection_id: 12959542-838cbea9-9628-4603-af25-de70548e04d1
  image: images/blueprints/more-organizational-visibility.jpeg 
  conclusion: Text
  tags:
  - Visibility
  - Public
  - Partner
  - Public
  roles:
  - Advocate
  - Architect
  - Operations
  - CIO
  - CISO
  - CTO
  - Engineering
  - Product  
  state: Work in Progress
  type: Observability
  maturity: Optimized
  level: 250
  areas:
  - label: Private
    description: The microservice and API growth within the enterprise has been the
      number one area of growth for APIs in the last five years. Having visibility,
      and making sense of the API sprawl that exists within the enterprise is the
      number challenge today. To be successful in their digital transformation enterprises
      must get a handle on the APIs that exist internally across teams, domains, acquisitions,
      and any other bounded context that has emerged in the last decade. API operations
      today are shaped by how much visibility leadership has when it comes to where
      API work is occurring, and how APIs and the lifecycle around them are made discoverable,
      observable, and secured. There are a handful of ways that enterprise organizations
      are getting a handle on their API operations inside the firewall, and it centers
      on looking at this problem in five distinct ways.
    image: images/lifecycle-arrow-define.png
    elements:
    - name: Network
      label: Network
    - name: Workspace
      label: Workspace
    - name: Repository
      label: Repository
    - name: APIs
      label: APIs
    - name: Operations
      label: Operations
  - label: Partner
    description: Everything we just discussed around visibility of internal enterprise
      operations applies to the world of making APIs available to partners, there
      are just a different set of added considerations when it comes to providing
      external, but trusted access to digital resources and capabilities. There are
      definitely more authentication, security, and other management considerations
      once you externalize APIs for access by partners, but you will need an entirely
      different team, processes, and feedback loop in place to support partner access
      to your valuable resources. Workspaces and Repository provide an excellent way
      for API producers to engage with partners, but depending on the API being made
      available, and the platform and infrastructure that exists beneath them, there
      are many other ways of engaging wit partners across the API lifecycle.
    image: images/lifecycle-arrow-define.png
    elements:
    - name: Network
      label: Network
    - name: Workspace
      label: Workspace
    - name: Repository
      label: Repository
    - name: APIs
      label: APIs
    - name: Operations
      label: Operations
  - label: Public
    description: Despite many enterprise organizations' hesitancy when it comes to
      making APIs available publicly to 3rd party developers, the publishing and evolution
      of publicly available APIs has continued to grow in some business sectors, and
      expand into entirely new sectors. Public workspaces have changed the game when
      it comes to visibility into the API producer and consumer relationship, letting
      more sunlight into the process, and expanding the rules of engagement. This
      evolution is shifting how we publish documentation for our APIs, but also how
      API producers accept feedback and contributions from consumers, learning from
      open source and allowing API artifacts to be watched, forked, and evolved through
      many individual conversation threads. Continue to shift API operations from
      within the enterprise out into the communities where developers and other API
      consumers are already engaging
    image: images/lifecycle-arrow-define.png
    elements:
    - name: Network
      label: Network
    - name: Workspace
      label: Workspace
    - name: Repository
      label: Repository
    - name: APIs
      label: APIs
    - name: Operations
      label: Operations
  discussion: ''
  yaml: ''
- name: API Workspaces as the Foundation
  version: '2021-11-24'
  description: Like Repository have done for code over the last decade, API workspaces
    have become the essential way for not just organizing API artifacts, but also
    the operations needed around them to move them forward. Providing teams with a
    way for organizing everything you need to produce and consume APIs within a single
    business domain or project into a discoverable and collaborative workspace.
  image: images/blueprints/api-workspaces-as-the-foundation.jpeg 
  conclusion: Text
  tags:
  - Workspaces
  roles:
  - Advocate
  - Architect
  - Backend
  - Data
  - Operations
  - Engineering
  - Frontend
  - Mobile
  - Product
  - Security
  - Support
  - Writer  
  state: Work in Progress
  type: Base
  maturity: Foundational
  level: 110
  areas:
  - label: Contents
    description: API workspaces are often compared to Git Repository until you begin
      to understand how more precise and relevant to the API lifecycle the contents
      are. Each workspace contains APIs artifacts, collections used to power mock
      servers, documentation, and testing, as well as individual Environment for development,
      staging, and production Environment, and monitors for automating the production
      and consumption of APIs. Once you begin to see hundreds of individual API workspaces
      all equipped with what is needed to design, develop, deploy, and manage APIs,
      all existing and operating independently to orchestrate a single enterprise
      operation, you begin to see what a modern API factory floor looks like. API
      workspaces have everything you need to produce and consume APIs, through APIs
      and integrations these dedicated workspaces can be used to power enterprise
      operations using internal, infrastructure, and 3rd party APIs to operate the
      factory floor each day.
    image: images/lifecycle-arrow-define.png
    elements:
    - name: Collection
      label: Collection
    - name: APIs
      label: APIs
    - name: Environment
      label: Environment
    - name: Monitor
      label: Monitor
  - label: Visibility
    description: The visibility of API workspaces is key to defining enterprise operations,
      providing the ability to keep work around APIs private amongst internal teams,
      available to trusted partners, as well as fully opening up for engagement with
      public consumers. This level of control over the visibility of not just APIs,
      but also the work that is occurring around them is critical for us to move beyond
      the past anxieties regarding public and private API access. The question isn't
      should we do public or private APIs, we must be doing both, and we need our
      API platform to support us in making this as easy as possible. Providing access
      to digital resources and capabilities is what APIs are all about, but being
      API-first also means you have full control over what is private or public, who
      has access to these resources, and you enjoy full visibility over what they
      have access to. Allowing enterprise organizations to be more confident regarding
      the visibility across their operations, and lower barriers to entry when it
      comes to access to digital resources and capabilities without compromising privacy,
      security, and reliability of operations.
    image: images/lifecycle-arrow-define.png
    elements:
    - name: Private
      label: Private
    - name: Partner
      label: Partner
    - name: Public
      label: Public
  - label: Engagement
    description: API workspaces are changing how API producers engage with consumers,
      dictating how teams within the enterprise work, and when a partner or 3rd party
      contributors will be able to join in the conversation. API workspaces give us
      control over the visibility of APIs and the operations around them and give
      us new insight into how teams are engaging with each other, and external consumers
      are watching and working with APIs, going beyond classic API management to drive
      engagement. Workspaces give us visibility into how teams are doing what they
      do and showcase the contributions of external actors when APIs are made accessible
      outside the firewall. API workspaces give us an entirely new approach that builds
      upon the developer portal practices popularized over the last decade, but then
      further expands and adapts it to the realities that exist on the ground of API
      operations today.
    image: images/lifecycle-arrow-define.png
    elements:
    - name: Contributors
      label: Contributors
    - name: Team
      label: Team
    - name: Watch
      label: Watch
    - name: Activity
      label: Activity
  discussion: ''
  yaml: ''
  collection_id: 12959542-6e4798fd-d9d5-4824-a466-9fef299a11c7
- name: Platform API Governance
  version: '2022-01-19'
  description: Leveraging a common platform workspace blueprint to define, develop,
    manage, observe and govern each API, providing the consistency needed to properly
    govern each individual API at scale across operations.
  image: images/blueprints/platform-api-governance.jpeg 
  conclusion: Text
  tags:
  - Governance
  roles:
  - Advocate
  - Architect
  - Operations
  - Engineering
  - Product
  - Security
  state: Work in Progress
  type: Base
  maturity: Foundational
  level: 220
  areas:
  - label: Definition
    description: Establishing a common base for each API, ensuring there is always
      a single location to understand what is happening with each API, standardizing
      how teams are working.
    image: images/lifecycle-arrow-define.png
    elements:
    - name: Workspace
      label: Workspace
    - name: OpenAPI
      label: OpenAPI
    - name: Documentation
      label: Documentation
    - name: Team
      label: Team
  - label: Software Development Lifecycle (SLDC)
    description: Leveraging the existing source control and CI/CD infrastructure to
      standardize how APIs are deployed, helping make sure the API lifecycle is more
      reliable and repeatable across operations.
    image: images/lifecycle-arrow-define.png
    elements:
    - name: Repository
      label: Repository
    - name: Pipeline
      label: Pipeline
  - label: Environment
    description: Ensuring that there is an artifact for each environment used to develop,
      stage, and operate APIs in production, providing a usable store of secrets,
      and other key/value pairs.
    image: images/lifecycle-arrow-define.png
    elements:
    - name: Production Environment
      label: Production Environment
    - name: Staging Environment
      label: Staging Environment
  - label: Contracts
    description: Making sure that the contract for every API is being tested, leveraging
      the JSON Schema within the OpenAPI contract to validate each of the responses
      being returned by an API.
    image: images/lifecycle-arrow-define.png
    elements:
    - name: Contract Testing
      label: Contract Testing
    - name: Contract Testing Monitor
      label: Contract Testing Monitor
    - name: Contract Testing Pipeline
      label: Contract Testing Pipeline
  - label: Performance
    description: Having the overall availability and performance of each API tested,
      and scheduled via a monitor, providing status updates of an API over time that
      is relevant to the APIs value.
    image: images/lifecycle-arrow-define.png
    elements:
    - name: Performance Testing
      label: Performance Testing
    - name: Performance Testing Monitor
      label: Performance Testing Monitor
  - label: Security
    description: Ensuring that a common set of security tests are being applied to
      each API, scanning for common vulnerabilities, patterns, and other potential
      security issues that affect APIs.
    image: images/lifecycle-arrow-define.png
    elements:
    - name: Security Testing
      label: Security Testing
    - name: Security Testing Monitor
      label: Security Testing Monitor
    - name: Security Testing Pipeline
      label: Security Testing Pipeline
  - label: Governance
    description: Leveraging a script and rules-based approach to governing the surface
      area of each API, helping automate the consistent in design, but also eventually
      the operations of APIs.
    image: images/lifecycle-arrow-define.png
    elements:
    - name: Design Governance
      label: Design Governance
  - label: Observability
    description: Pushing for a minimal amount of observability available for all APIs,
      allowing any team member, stakeholder, or in some cases 3rd party developers
      to see history and activity for each API.
    image: images/lifecycle-arrow-define.png
    elements:
    - name: Reports
      label: Reports
    - name: APM
      label: APM
    - name: History
      label: History
    - name: Activity
      label: Activity
  discussion: ''
  yaml: ''
  collection_id: 12959542-2cddb93b-1773-4d75-bfff-a3cfdfa5224f
- name: Workspace Standardization
  version: '2022-01-19'
  description: This is a blueprint to standardize how workspaces are setup.
  image: images/blueprints/workspace-standardization.jpeg 
  conclusion: Text
  tags:
  - Workspaces
  roles:
  - Advocate
  - Architect
  - Operations
  - Product
  - Support
  state: Work in Progress
  type: Base
  maturity: Foundational
  level: 170
  areas:
  - label: Resources
    description: These resources should be made available to teams as part of workspace
      standardization.
    image: images/lifecycle-arrow-define.png
    elements:
    - name: Workspace Guidance
      label: Workspace Guidance
  - label: Workspace
    description: These are some of the areas for workspace standardization.
    image: images/lifecycle-arrow-define.png
    elements:
    - name: Workspace Name
      label: Workspace Name
    - name: Workspace Overview
      label: Workspace Overview
    - name: Workspace RBAC
      label: Workspace RBAC
  - label: APIs
    description: These are some of the areas for API standardization.
    image: images/lifecycle-arrow-define.png
    elements:
    - name: API Name
      label: API Name
    - name: API Overview
      label: API Overview
    - name: API RBAC
      label: API RBAC
  - label: Collection
    description: These are some of the areas for collection standardization.
    image: images/lifecycle-arrow-define.png
    elements:
    - name: Collection Name
      label: Collection Name
    - name: Collection Base URL
      label: Collection Base URL
    - name: Collection Overview
      label: Collection Overview
    - name: Collection Authentication
      label: Collection Authentication
    - name: Collection Variables
      label: Collection Variables
    - name: Collection Folders
      label: Collection Folders
    - name: Collection RBAC
      label: Collection RBAC
  - label: Environment
    description: These are some of the areas for environment standardization.
    image: images/lifecycle-arrow-define.png
    elements:
    - name: Environment Name
      label: Environment Name
    - name: Environment Overview
      label: Environment Overview
    - name: Environment Type
      label: Environment Type
    - name: Environment RBAC
      label: Environment RBAC
  - label: Mock Servers
    description: These are some of the areas for mock servers standardization.
    image: images/lifecycle-arrow-define.png
    elements:
    - name: Mock Server Names
      label: Mock Server Names
  - label: Monitor
    description: These are some of the areas for monitor standardization.
    image: images/lifecycle-arrow-define.png
    elements:
    - name: Monitor Names
      label: Monitor Names
  - label: Benefits
    description: Some of the benefits for workspace standardization.
    image: images/lifecycle-arrow-define.png
    elements:
    - name: Increased Developer Productivity
      label: Increased Developer Productivity
    - name: Improved Developer Satisfaction
      label: Improved Developer Satisfaction
    - name: Team Onboarding
      label: Team Onboarding
    - name: Consumer Onboarding
      label: Consumer Onboarding
  discussion: ''
  yaml: ''
  collection_id: 12959542-4301fa94-c86d-4fa7-a55d-ea917970a2c5
- name: What is an API?
  version: '2022-02-22'
  description: API stands for application programming interface. APIs are the little pieces of code that make it possible for digital devices, software applications, and data servers to talk with each other, and theyre the essential backbone of so many services we now rely on.
  collection_id: 
  image: images/blueprints/api-design-first.jpeg
  tags:
  - API
  roles:
  - CIO
  - CEO
  - CTO
  - Sales
  - Support
  state: Work In Progress
  type: Design
  maturity: Optimized
  level: 101
  areas:
  - label: Filler
    description: This is just filler content
    image: images/lifecycle-arrow-define.png
    elements:
    - name: API Lifecycle
      label: API Lifecycle
  discussion: ''
  yaml: ''
- name: What are examples of APIs?
  version: '2022-02-22'
  description: Every company you think of when it comes to the online digital has APIs, with some of the most notable companies like Amazon, Facebook, Twitter, Google, Microsoft and others leading this digital expansion. Demonstrating how APIs have moved from a tech sector solution to a mainstream business solution that is touching almost every business sector today.
  collection_id: 
  image: images/blueprints/api-design-first.jpeg
  tags:
  - API
  roles:
  - CIO
  - CEO
  - CTO
  - Sales
  - Support
  state: Work In Progress
  type: Design
  maturity: Optimized
  level: 102
  areas:
  - label: Filler
    description: This is just filler content
    image: images/lifecycle-arrow-define.png
    elements:
    - name: API Lifecycle
      label: API Lifecycle
  discussion: ''
  yaml: ''  
- name: Why do APIs matter?
  version: '2022-02-22'
  description: APIs have been behind every shift in the technological landscape during last twenty years. Commerce and payments  APIs. The social revolution introduced by Facebook and Twitter  APIs. Cloud computing  APIs. Mobile  APIs. Internet-connected devices  APIs. Machine learning  APIs. It is all APIs. If you are looking to be the one who defines the future of how business is conducted, youll need to be API-aware. You should care about APIs because it will play a role in defining almost every aspect of how you get business done in the next decade.
  collection_id: 
  image: images/blueprints/api-design-first.jpeg
  tags:
  - API
  roles:
  - CIO
  - CEO
  - CTO
  - Sales
  - Support
  state: Work In Progress
  type: Design
  maturity: Optimized
  level: 103
  areas:
  - label: Filler
    description: This is just filler content
    image: images/lifecycle-arrow-define.png
    elements:
    - name: API Lifecycle
      label: API Lifecycle
  discussion: ''
  yaml: ''   
- name: What is your time to first call?
  version: '2022-02-22'
  description: Time to first call (TTFC) can be the most important API metric, but its not the only one. So why is it more important than other metrics, like later-stage usage or performance? As an API publisher, you API journey may look a little different. But the majority of developers get it and buy in once they have a chance to interact with an API on their own terms. Legitimately streamlining TTFC results in a larger market potential of better-educated users for the later stages of your developer journey.
  collection_id: 
  image: images/blueprints/api-design-first.jpeg
  tags:
  - Onboarding
  - Getting Started
  - Documentation
  roles:
  - Advocate 
  - Writers
  state: Work In Progress
  type: Design
  maturity: Optimized
  level: 330
  areas:
  - label: Filler
    description: This is just filler content
    image: images/lifecycle-arrow-define.png
    elements:
    - name: API Lifecycle
      label: API Lifecycle
  discussion: ''
  yaml: ''  
- name: How to setup your first public workspace
  version: '2022-02-22'
  description: API builders are excited about public workspaces because it opens up an entirely new way to collaborate with folks beyond their immediate team. Some want users to learn about and use their API. Others want to stress test and gather user feedback to improve their API. Some are community organizers creating resource centers for data-driven initiatives.
  collection_id: 
  image: images/blueprints/api-design-first.jpeg
  tags:
  - Onboarding
  - Getting Started
  - Documentation
  roles:
  - Advocate 
  - Writers
  state: Work In Progress
  type: Design
  maturity: Optimized
  level: 290
  areas:
  - label: Filler
    description: This is just filler content
    image: images/lifecycle-arrow-define.png
    elements:
    - name: API Lifecycle
      label: API Lifecycle
  discussion: ''
  yaml: ''  
- name: Public Workspaces and Your API Portal Working Together
  version: '2022-02-22'
  description: Postman public workspaces are quickly becoming an essential part of every public API. API producers want to increase adoption of their APIs and enable a faster time to first call (TTFC). A bazillion teams have created their first public workspace, and almost everyone has the same question--What is the best way to link my public workspace to my developer docs? You could simply drop a link to the public workspace in your developer docs, but clever producers want to know the best way to do it. In this article, lets walk through examples of public APIs that have created a good experience for developers browsing docs to make their first API calls in Postman.
  collection_id: 
  image: images/blueprints/api-design-first.jpeg
  tags:
  - Onboarding
  - Getting Started
  - Documentation
  roles:
  - Advocate 
  - Writers
  state: Work In Progress
  type: Design
  maturity: Optimized
  level: 310
  areas:
  - label: Filler
    description: This is just filler content
    image: images/lifecycle-arrow-define.png
    elements:
    - name: API Lifecycle
      label: API Lifecycle
  discussion: ''
  yaml: ''  